<section id="functional">

    <section>
        <h2>Paradigme Fonctionnel</h2>
    </section>

    <section>
        <h3>Programmation fonctionnelle</h3>
        <p>
            La programmation fonctionnelle est un <strong>paradigme de programmation</strong> qui consid√®re le calcul
            comme l'√©valuation de fonctions math√©matiques et √©vite les changements d'√©tat et les donn√©es mutables.
        </p>
        <p>
            Les langages de programmation fonctionnelle sont bas√©s sur les concepts de fonctions pures, d'immuabilit√© et de r√©cursivit√©.
        </p>
    </section>

    <section>
        <h3>Languages fonctionnels</h3>
        <ul>
            <li>
                <a href="https://www.haskell.org/" target="_blank">Haskell</a> :
                langage de programmation fonctionnel pur, cr√©√© en 1990. Ce langage essai de respecter le plus possible
                les principes de la programmation fonctionnelle.
            </li>
            <li>
                <a href="https://fsharp.org/" target="_blank">F#</a> :
                langage de programmation fonctionnel imp√©ratif, cr√©√© en 2005 par Microsoft. Il est utilis√© pour le
                d√©veloppement d'applications web, mobiles et cloud.
            </li>
            <li>
                <a href="https://www.erlang.org/" target="_blank">Erlang</a> :
                langage de programmation fonctionnel concurrent, cr√©√© en 1986 par la soci√©t√© Ericsson. Il est utilis√©
                pour le d√©veloppement de syst√®mes distribu√©s et tol√©rants aux pannes (let it crash).
            </li>
            <li>
                <a href="https://www.scala-lang.org/" target="_blank">Scala</a> :
                langage de programmation fonctionnel et orient√© objet, cr√©√© en 2003. Il est bas√© sur la machine virtuelle
                Java et permet de combiner les avantages de la programmation fonctionnelle et de la programmation orient√©e objet.
            </li>
        </ul>
        <p>
            Par la suite, nous aborderons quelques examples de programmation fonctionnelle en Haskell que vous pourrez
            ex√©cuter directement dans votre navigateur (<a href="https://play.haskell.org/">https://play.haskell.org/</a>).
        </p>
    </section>

    <section>
        <h3>JavaScript</h3>
        <p>
            JavaScript est un langage de programmation de haut niveau, interpr√©t√©, multi-paradigme.
        </p>
        <p>
            Il s'agit initialement d'un <strong>langage de script pour les pages web</strong>, mais il est √©galement
            utilis√© pour programmer des serveurs, des applications mobiles et des jeux vid√©o...
        </p>
        <p>
            Nous allons utiliser ensemble Node.js pour ex√©cuter du code JavaScript en mode console.
        </p>
        <p>
            Voici les commandes √† taper dans un terminal pour installer Node.js et npm :
        </p>
        <div class="container">
            <div class="col">
                <h4>macOS</h4>
                <pre><code class="language-bash">brew install node</code></pre>
            </div>
            <div class="col">
                <h4>Windows</h4>
                <pre><code class="language-bash">scoop install nodejs</code></pre>
            </div>
        </div>
    </section>

    <section>
        <h3>Node.js</h3>
        <p>
            Node.js est un environnement d'ex√©cution <strong>JavaScript c√¥t√© serveur</strong>,
            bas√© sur le moteur JavaScript V8 de Google.
        </p>
        <p>
            Il permet d'ex√©cuter du code JavaScript en dehors d'un navigateur web, et d'interagir avec le syst√®me
            d'exploitation.
        </p>
        <p>
            Pour cr√©er un projet Node.js, il suffit de cr√©er un fichier <code>index.js</code>
            et d'y √©crire du code JavaScript :
        </p>
        <pre><code class="language-js">console.log('Hello, World!');</code></pre>
        <p>
            Pour ex√©cuter ce code, il suffit de taper la commande suivante dans un terminal :
        </p>
        <pre><code class="language-bash">node index.js</code></pre>
    </section>

    <section>
        <h3>Fonctions pures</h3>
        <p>
            Une fonction pure est une fonction qui, pour une entr√©e donn√©e, retourne
            <strong>toujours la m√™me sortie</strong> et n'a <strong>pas d'effets de bord</strong>.
        </p>
        <p>
            Un contre-exemple en JavaScript est la fonction <code class="language-js">sort()</code> qui modifie l'ordre
            des √©l√©ments d'un tableau au lieu de retourner un nouveau tableau tri√© comme le ferait une fonction pure
            telle que <code class="language-js">filter()</code>.
        </p>
        <pre><code class="language-js">const arr = [3, 1, 2];
arr.sort(); // Cette fonction va modifier la variable arr
console.log(arr); // [1, 2, 3]
arr.filter(function (x) { return x > 1; }); // Cette fonction ne va pas modifier arr mais retourner un nouveau tableau
console.log(arr); // [1, 2, 3]</code></pre>
        <p>
            La fonction <code class="language-js">sort()</code> est un exemple de fonction impure, car elle modifie
            l'√©tat global du tableau <code class="language-js">arr</code> et a donc un effet de bord.
        </p>
        <footer>
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted" class="info" target="_blank">
                MDN Web Docs - Array.prototype.toSorted()
            </a>
        </footer>
    </section>

    <section>
        <h3>Fonctions pures</h3>
        <p>
            Dans l'exemple ci-dessous, la fonction <code class="language-js">calculateAge</code> n'est pas une fonction
            pure, car elle utilise la date actuelle pour calculer l'√¢ge de l'utilisateur.
        </p>
        <pre><code class="language-js">function calculateAge(birthDate) {
    const now = new Date(); // Ne retourne pas toujours la m√™me valeur
    const diff = now - birthDate;
    const age = Math.floor(diff / (1000 * 60 * 60 * 24 * 365.25));
    return age;
}</code></pre>
        <p>
            Pour rendre cette fonction pure, il faudrait passer la date actuelle en param√®tre.
        </p>
    </section>

    <section>
        <h3>Fonctions pures</h3>
        <p>
            Les fonctions pures ont plusieurs avantages :
        </p>
        <ul>
            <li>
                Elles sont plus faciles √† <strong>tester</strong>.<br>
                Dans l'exemple pr√©c√©dent, il est difficile de tester la fonction
                <code class="language-js">calculateAge()</code> car elle d√©pend de la date actuelle et le r√©sultat du
                test variera en fonction de la date d'ex√©cution.
            </li>
            <li>
                Elles sont plus faciles √† <strong>comprendre</strong>.<br>
                Les fonctions pures sont auto-document√©es, car elles ne d√©pendent que de leurs param√®tres d'entr√©e.
            </li>
            <li>
                Elles sont plus faciles √† <strong>parall√©liser</strong>.<br>
                Les fonctions pures peuvent √™tre ex√©cut√©es en parall√®le sans risque de conflits de donn√©es, car elles
                n'ont pas d'effets de bord comme par exemple la modification d'une variable globale.
            </li>
            <li>
                Elles sont plus faciles √† <strong>optimiser</strong>.<br>
                Les fonctions pures peuvent √™tre mises en cache pour √©viter de recalculer le m√™me r√©sultat plusieurs
                fois (m√©mo√Øsation).
            </li>
        </ul>
    </section>

    <section>
        <h3>Exercice</h3>
        <p>
            Parmi les fonctions suivantes, lesquelles sont pures ?
        </p>
        <ol>
            <li>
                <pre><code class="language-js">function add(x, y) { return x + y; }</code></pre>
            </li>
            <li>
                <pre><code class="language-js">function random() { return Math.random(); }</code></pre>
            </li>
            <li>
                <pre><code class="language-js">function greet(name) { return 'Hello, ' + name; }</code></pre>
            </li>
            <li>
                <pre><code class="language-js">function square(x) { return x * x; }</code></pre>
            </li>
            <li>
                <pre><code class="language-js">function now() { return new Date(); }</code></pre>
            </li>
            <li>
                <pre><code class="language-js">function display(message) { console.log(message); }</code></pre>
            </li>
            <li>
                <pre><code class="language-js">function sum(arr) { return arr.reduce((acc, x) => acc + x, 0); }</code></pre>
            </li>
            <li>
                <pre><code class="language-js">function uppercase(user) { user.lastname = user.lastname.toUpperCase(); }</code></pre>
            </li>
        </ol>
    </section>

    <section>
        <h3>React</h3>
        <p>
            React est une biblioth√®que JavaScript open-source pour la <strong>cr√©ation d'interfaces utilisateur</strong>
            qui utilise le paradigme de <strong>programmation fonctionnelle</strong> (bien qu'il √©tait possible dans
            les premi√®res versions de React de cr√©er des composants en utilisant le paradigme de la programmation
            orient√©e objet).
        </p>
        <p>
            React utilise des composants pour structurer l'interface utilisateur et
            <a href="https://react.dev/reference/rules/components-and-hooks-must-be-pure" target="_blank">encourage</a>
            la cr√©ation de composants <strong>purs</strong> qui ne d√©pendent que de leurs propri√©t√©s (props) pour
            afficher leur √©tat.
        </p>
        <p>
            React utilise aussi le concept de
            <a href="https://react.dev/learn/react-compiler#what-does-the-compiler-do" target="_blank">m√©mo√Øsation</a>
            pour √©viter de recalculer le rendu d'un composant si ses propri√©t√©s n'ont pas chang√©.
        </p>
    </section>

    <section>
        <h3>Expressions lambda</h3>
        <p>
            Les expressions lambda (√©galement appel√©es fonctions anonymes) sont des fonctions sans nom qui sont souvent
            utilis√©es pour passer des fonctions en tant qu'arguments √† d'autres fonctions.
        </p>
        <p>
            Nous avons vu un exemple d'expression lambda dans la section pr√©c√©dente avec la fonction
            <code class="language-js">filter()</code> :
        </p>
        <pre><code class="language-js">const arr = [1, 2, 3];
const filtered = arr.filter(function (x) { return x > 1; });</code></pre>
    </section>

    <section>
        <h3>Expressions lambda</h3>
        <p>
            En JavaScript, les expressions lambda peuvent √™tre √©crites de mani√®re plus concise √† l'aide de la syntaxe
            des <strong>fonctions fl√©ch√©es</strong> :
        </p>
        <pre><code class="language-js">const arr = [1, 2, 3];
const filtered = arr.filter(x => x > 1);</code></pre>
        <p>
            Les fonctions fl√©ch√©es sont plus courtes et plus lisibles que les fonctions anonymes traditionnelles.
        </p>
    </section>

    <section>
        <h3>Expressions lambda</h3>
        <p>
            Hormis une diff√©rence de syntaxe, les
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank">fonctions fl√©ch√©es</a>
            ont un comportement l√©g√®rement diff√©rent en ce qui concerne le mot-cl√© <code class="language-js">this</code>.
        </p>
        <pre><code class="language-js">const person = {
    firstName: 'John',
    lastName: 'Doe',
    fullName: function() {
        let fn = function() {
            console.log(this); // this is the global object
            console.log(this.firstName + ' ' + this.lastName); // undefined undefined
        }
        fn();
        let lambda = () => {
            console.log(this); // this is the person object
            console.log(this.firstName + ' ' + this.lastName); // John Doe
        };
        lambda();
    }
}

person.fullName();</code></pre>
    </section>

    <section>
        <h3>Expressions lambda</h3>
        <p>
            On retrouve les expressions lambda dans de nombreux langages de programmation :
        </p>
        <ul>
            <li>
                En Python :<br>
                <code class="language-python">square = lambda x: x * x</code>.
            </li>
            <li>
                En C# :<br>
                <code class="language-csharp">Func&lt;int, int&gt; square = x => x * x;</code>.
            </li>
            <li>
                En Java :<br>
                <code class="language-java">Function&lt;Integer, Integer&gt; square = x -> x * x;</code>.
            </li>
        </ul>
    </section>

    <section>
        <h3>Expressions lambda - Exercice</h3>
        <div class="instructions">
            <ol>
                <li>
                    Cr√©ez une fonction lambda qui filtre les nombres pairs d'un tableau.
                </li>
                <li>
                    Cr√©ez une fonction lambda qui affiche un d√©compte de 3 √† 0 en utilisant la fonction
                    <code class="language-js">setInterval()</code>.
                </li>
                <li>
                    Cr√©ez une fonction lambda qui calcule la somme des √©l√©ments d'un tableau en utilisant la m√©thode
                    <code class="language-js">reduce()</code>.
                </li>
                <li>
                    Cr√©ez une fonction lambda pour demander √† l'utilisateur de saisir son pr√©nom en utilisant le
                    module <code class="language-js">readline</code> de Node.js.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>R√©cursivit√©</h3>
        <p>
            La r√©cursivit√© est une technique de programmation dans laquelle une fonction s'appelle elle-m√™me pour r√©soudre un probl√®me plus petit.
        </p>
        <blockquote>
            <p>
                "To understand recursion, you must first understand recursion."
            </p>
            <cite>Anonymous</cite>
        </blockquote>
    </section>

    <section>
        <h3>R√©cursivit√© VS It√©ration</h3>
        <p>
            La r√©cursivit√© est couramment utilis√©e en programmation fonctionnelle pour remplacer les boucles.
            Cependant, la r√©cursivit√© ne permet pas d'am√©liorer les performances, car chaque appel de fonction cr√©e une nouvelle pile d'ex√©cution.
        </p>
        <div class="container">
            <div class="col">
                <h4>R√©cursivit√©</h4>
                <pre><code class="language-javascript">function factorial(n) {
    if (n === 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}</code></pre>
            </div>
            <div class="col">
                <h4>It√©ration</h4>
                <pre><code class="language-javascript">function factorial(n) {
    let result = 1;
    for (let i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}</code></pre>
            </div>
        </div>
        <footer>
            <a href="https://stackoverflow.com/questions/9386375/efficiency-recursion-vs-loop" target="_blank">Stack Overflow - Efficiency: recursion vs. loop</a>
        </footer>
    </section>

    <section>
        <h3>R√©cursivit√© en Haskell</h3>
        <p>
            Le langage Haskell est un langage de programmation fonctionnel pur qui repose sur la r√©cursivit√© pour l'it√©ration.
            Il ne supporte pas les boucles comme <code>for</code> ou <code>while</code> que l'on retrouve dans les langages imp√©ratifs.
        </p>
        <pre><code class="language-haskell">factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)

main :: IO ()
main = do
    print (factorial 5) -- 120</code></pre>
    </section>

    <section>
        <h3>R√©cursivit√© sur tableau</h3>
        <p>
            La r√©cursivit√© peut √™tre utilis√©e pour parcourir un tableau en appelant une fonction r√©cursive sur chaque √©l√©ment.
        </p>
        <pre><code class="language-js">function sum(arr) {
    if (arr.length === 0) {
        return 0;
    } else {
        return arr[0] + sum(arr.slice(1)); // Head + Tail
    }
}</code></pre>
        <p>
            En Haskell, cette fonction s'√©crit de la mani√®re suivante :
        </p>
        <pre><code class="language-haskell">sum :: [Integer] -> Integer
sum [] = 0
sum (head:tail) = head + sum tail</code></pre>
    </section>

    <section>
        <h3>R√©cursivit√© - Exercice</h3>
        <div class="instructions">
            <ol>
                <li>
                    Cr√©ez une fonction r√©cursive <code class="language-js">flatten(arr)</code> qui retourne un tableau
                    √† une dimension √† partir d'un tableau multidimensionnel.
                    <pre><code class="language-js">console.log(flatten([1, [2, [3, [4]], 5]])); // [1, 2, 3, 4, 5]</code></pre>
                </li>
                <li>
                    Cr√©ez une fonction r√©cursive <code class="language-js">binaryTreeSum(tree)</code> qui retourne la
                    somme des valeurs d'un arbre binaire.
                    <pre style="max-width: 100%; overflow-x: auto;"><code class="language-js">const tree = {
    value: 1,
    left: {
        value: 2,
        left: { value: 3, left: null, right: null },
        right: { value: 4, left: null, right: null }
    },
    right: { value: 5, left: null, right: null }
};
console.log(binaryTreeSum(tree)); // 15</code></pre>
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Promises</h3>
        <p>
            Une promesse (promise) est un objet qui repr√©sente la r√©ussite ou l'√©chec d'une op√©ration asynchrone.
        </p>
        <p>
            Les promesses sont couramment utilis√©es en JavaScript pour g√©rer les <strong>op√©rations asynchrones</strong>
            comme les appels r√©seau, les acc√®s √† la base de donn√©es ou les interactions avec l'utilisateur.
        </p>
        <pre><code class="language-js">const promise = new Promise((resolve, reject) => { // resolve et reject sont des fonctions de rappel
    setTimeout(() => {
        const success = Math.random() > 0.5;
        if (success) {
            resolve('Success!'); // La promesse est r√©solue
        } else {
            reject('Failure!'); // La promesse est rejet√©e
        }
    }, 1000);
});

promise.then(result => console.log(result)) // Success!
       .catch(error => console.error(error)); // Failure!</code></pre>
    </section>

    <section>
        <h3>Promises</h3>
        <p>
            Les promesses permettent de simplifier la gestion des op√©rations asynchrones en √©vitant le syndrome de
            <strong>l'entrelacement</strong> (<a href="http://callbackhell.com/" target="_blank">callback hell</a>).
        </p>
        <p>
            Elles sont tr√®s souvent utilis√©es en JavaScript avec les mots-cl√©s <code>async</code> et <code>await</code>
            pour rendre le code plus lisible et plus facile √† comprendre :
        </p>
        <pre><code class="language-js">function fetchData(url, callback, err) {
    fetch(url)
        .then(response => response.json())
        .then(json => callback(json));
        .catch(error => err(error));
}</code></pre>
        <pre><code class="language-js">async function fetchData(url) {
    const response = await fetch(url);
    const json = await response.json();
    return json;
}</code></pre>
    </section>

    <section>
        <h3>Promises - NodeJS</h3>
        <p>
            NodeJS propose dans sa biblioth√®que standard des fonctions qui retournent des promesses, comme par exemple
            <code class="language-js">fs.promises.readFile()</code> pour lire un fichier.
        </p>
        <a href="https://nodejs.org/en/learn/manipulating-files/reading-files-with-nodejs" target="_blank">
            Node.js - Reading files with Node.js
        </a>
    </section>

    <section>
        <h3>Exercice - Promises</h3>
        <div class="instructions">
            <ol>
                <li>
                    Utilisez les fonctions <code class="language-js">fs.readdir()</code> et <code class="language-js">fs.stat()</code>
                    pour lister les fichiers d'un r√©pertoire et afficher leur taille.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Closures</h3>
        <p>
            Une fermeture (closure) est une fonction qui capture les variables de son environnement lexical.
        </p>
        <p>
            Les fermetures sont couramment utilis√©es en JavaScript pour cr√©er des fonctions qui conservent l'√©tat de
            leur environnement d'ex√©cution.
        </p>
        <pre><code class="language-js">function makeCounter() {
    let count = 0;
    return () => count++; // ‚ö†Ô∏è Cette fonction retourne la valeur actuelle de count
}

const counter = makeCounter();
console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2</code></pre>
    </section>

    <section>
        <h3>Closures</h3>
        <p>
            Les fermetures permettent de retrouver des concepts de la programmation orient√©e objet comme l'encapsulation
            et l'abstraction :
        </p>
        <pre><code class="language-js">function createPerson(name) {
    return {
        getName: () => name,
        setName: (newName) => name = newName
    };
}

const person = createPerson('Alice');
console.log(person.getName()); // Alice
person.setName('Bob');
console.log(person.getName()); // Bob</code></pre>
    </section>

    <section>
        <h3>Closure - Exercice</h3>
        <div class="instructions">
            <ol>
                <li>
                    Cr√©ez une fonction <code class="language-js">createCharacter(name, health)</code> qui retourne un
                    personnage avec un nom et une sant√©.
                </li>
                <li>
                    Cr√©ez une fonction <code class="language-js">getName()</code> qui retourne le nom du personnage.
                </li>
                <li>
                    Cr√©ez une fonction <code class="language-js">attack(character, damage)</code> qui r√©duit la sant√©
                    du personnage de la valeur du dommage.
                </li>
                <li>
                    Cr√©ez une fonction <code class="language-js">heal(health)</code> qui augmente la sant√©
                    du personnage de la valeur de la gu√©rison.
                </li>
                <li>
                    Cr√©ez une fonction <code class="language-js">isAlive()</code> qui retourne <code>true</code>
                    si la sant√© du personnage est sup√©rieure √† z√©ro.
                </li>
                <li>
                    Cr√©er une fonction <code class="language-js">doSomething()</code> qui effectue une action al√©atoire
                    (attaque ou gu√©rison) pendant un combat.
                </li>
                <li>
                    Cr√©ez une fonction <code class="language-js">fight()</code> qui simule un combat entre deux personnages.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Currying</h3>
        <p>
            La currification (currying) est une technique de <strong>transformation</strong> d'une fonction qui prend
            <strong>plusieurs arguments</strong> en une s√©quence de <strong>fonctions qui prennent un seul argument</strong>.
        </p>
        <p>
            La currification est bas√©e sur le principe de fermeture (closure) et est couramment utilis√©e en programmation
            fonctionnelle pour cr√©er des fonctions partielles.
        </p>
        <p>
            On peut repr√©senter la currification d'une fonction <code class="language-js">add(x, y)</code> comme une
            suite de fonctions <code class="language-js">add(x)(y)</code> :
        </p>
        <pre><code class="language-js">function add(x) {
    return y => x + y;
}

const add2 = add(2);
console.log(add2(3)); // 5</code></pre>
    </section>

    <section>
        <h3>Currying - Exemple</h3>
        <p>
            La currification est utile pour cr√©er des fonctions partielles qui peuvent √™tre r√©utilis√©es avec des arguments
            diff√©rents.
        </p>
        <p>
            Dans cet exemple, nous avons une fonction <code class="language-js">log(date, level, message)</code>
            qui affiche un message de journalisation avec une date, un niveau de log et un message :
        </p>
        <pre><code class="language-js">function log(date, level, message) {
    console.log(`[${date}] [${level}] ${message}`);
}</code></pre>
        <p>
            L'utilisation de cette fonction est <strong>fastidieuse</strong>, car il faut sp√©cifier la date et le
            niveau de log √† chaque appel :
        </p>
        <pre><code class="language-js">log(new Date(), 'INFO', 'First log');
log(new Date(), 'INFO', 'Second log');</code></pre>
    </section>

    <section>
        <h3>Currying - Exemple</h3>
        <p>
            En utilisant la currification, nous pouvons cr√©er une fonction <code class="language-js">info(message)</code>
            qui affiche un message de journalisation avec un niveau de log <code class="language-js">INFO</code> :
        </p>
        <pre><code class="language-js">const logToday = log(new Date());
const info = logToday('INFO');
info('First log');
info('Second log');</code></pre>
        <p>
            La fonction <code class="language-js">info()</code> est une fonction partielle qui conserve la date et le
            niveau de log pour chaque appel.
        </p>
        <p>
            Voici comment nous pouvons impl√©menter la currification de la fonction <code class="language-js">log()</code> :
        </p>
        <pre><code class="language-js">function log(date) {
    return level => message => console.log(`[${date}] [${level}] ${message}`);
}</code></pre>
    </section>

    <section>
        <h3>Currying - Exemple</h3>
        <p>
            La currification peut √©galement √™tre pratique lorsque l'on utilise des <strong>librairies externes</strong>
            et que l'on souhaite souvent appeler une fonction avec les m√™mes arguments.
        </p>
        <pre class="language-js"><code>import { filter } from 'lodash'; // La fonction filter prend 2 arguments (un tableau et une fonction)

const isEven = x => x % 2 === 0;
const createFilter = predicate => arr => filter(arr, predicate); // Currification de la fonction filter
const filterEven = createFilter(isEven); // Fonction partielle qui filtre les nombres pairs
console.log(filterEven([1, 2, 3, 4, 5])); // [2, 4]</code></pre>
    </section>

    <section>
        <h3>Currying - Haskell</h3>
        <p>
            Le langage Haskell impose l'utilisation de la currification puisque le langage
            <strong>ne permet pas de passer plusieurs param√®tres √† une fonction</strong> üò≥ !
        </p>
        <p>
            (en r√©alit√©, c'est possible, mais le <strong>langage effectuera la currification</strong> pour nous automatiquement)
        </p>
        <pre class="language-haskell"><code>add :: Num a => a -> a -> a -- √âquivalent de Num a => a -> (a -> a)
add x y = x + y

addTuple = uncurry add -- Cette fonction attend 1 seul argument de type tuple</code></pre>
    </section>

    <section>
        <h3>Currying - Exercice</h3>
        <div class="instructions">
            <ol>
                <li>
                    En utilisant la fonction pr√©c√©dente, comment cr√©er et utiliser une fonction
                    <code class="language-js">errorToday(message)</code> qui affiche un message de journalisation avec un
                    niveau de log <code class="language-js">ERROR</code> ?
                </li>
                <li>
                    Cr√©ez une fonction <code class="language-js">add(x, y, z)</code> qui retourne la somme des trois
                    arguments.
                </li>
                <li>
                    En utilisant la fonction <code class="language-js">add()</code>, utilisez la currification pour cr√©er une fonction <code class="language-js">add5(x)</code> qui
                    ajoute 5 √† un nombre.
                </li>
                <li>
                    En utilisant la fonction <code class="language-js">add()</code>, utilisez la currification pour cr√©er une fonction <code class="language-js">add10(x)</code> qui
                    ajoute 10 √† un nombre.
                </li>
                <li>
                    En utilisant la fonction <code class="language-js">add()</code>, utilisez la currification pour cr√©er une fonction <code class="language-js">add5and10(x)</code> qui
                    ajoute 5 et 10 √† un nombre.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Higher-Order Functions</h3>
        <p>
            Les fonctions d'ordre sup√©rieur (higher-order functions) sont des fonctions qui prennent d'autres fonctions
            en tant qu'arguments ou qui retournent des fonctions (ou les deux en m√™me temps).
        </p>
        <p>
            Par exemple, nous avons vu la fonction <code class="language-js">filter()</code> qui prend une fonction
            de test en argument et retourne un nouveau tableau contenant les √©l√©ments qui passent le test.
        </p>
    </section>

    <section>
        <h3>React</h3>
        <p>
            React utilise le concept de fonctions d'ordre sup√©rieur pour cr√©er des <strong>composants r√©utilisables</strong>.
        </p>
        <p>
            Ces composants sont appel√©s <strong>High-order components (HOC)</strong>. Ils prennent un composant en
            argument et retournent un nouveau composant avec des fonctionnalit√©s suppl√©mentaires.
        </p>
    </section>

    <section>
        <h3>Exercice - mapToList</h3>
        <div class="instructions">
            <ul>
                <li>
                    Cr√©er une fonction <code class="language-js">mapToList()</code> prenant en param√®tre une fonction
                    de transformation et un tableau, et retournant un nouveau tableau avec les √©l√©ments transform√©s.
                </li>
                <li>
                    Cette fonction devra reproduire le comportement de la m√©thode <code class="language-js">map()</code>
                    de JavaScript, mais en ajoutant une puce devant chaque √©l√©ment.
                </li>
                <li>
                    Exemple :
                    <pre><code class="language-js">const arr = [1, 2, 3];
const result = mapToList(x => x * x, arr);
console.log(result); // ['‚Ä¢ 1', '‚Ä¢ 4', '‚Ä¢ 9']</code></pre>
                </li>
            </ul>
        </div>
    </section>

    <section>
        <h3>Exercice - M√©moization</h3>
        <p>
            La m√©mo√Øsation (memoization) est une technique de programmation qui consiste √† stocker le r√©sultat d'une
            fonction pour √©viter de le recalculer si les m√™mes arguments sont pass√©s √† nouveau.
        </p>
        <div class="instructions">
            <ol>
                <li>
                    Appelez la fonction <code class="language-js">fibonacci(n)</code> avec le nombre 40 et mesurez
                    le temps d'ex√©cution en utilisant les m√©thodes <code class="language-js">console.time()</code>
                    et <code class="language-js">console.timeEnd()</code>.
                </li>
                <li>
                    Cr√©ez une fonction <code class="language-js">memoize(fn)</code> qui sera une fonction d'ordre sup√©rieur
                    et qui prendra en param√®tre une fonction et retournera une nouvelle fonction qui m√©morisera les r√©sultats.
                </li>
            </ol>
        </div>
        <p>
            Vous aurez besoin de r√©cup√©rer l'ensemble des arguments pass√©s √† une fonction. Pour cela, vous pouvez utiliser
            le spread operator <code class="language-js">...</code> :
        </p>
        <pre><code class="language-js">(...args) => { /* ... */ }</code></pre>
        <footer>
            <a href="#" class="info">La m√©mo√Øsation utilise le concept de fermeture (closure)</a>
        </footer>
    </section>

    <section>
        <h3>Exercice - TicTacToe</h3>
        <p>
            Reproduire le jeu du Morpion (Tic-Tac-Toe) que vous avez r√©alis√© en programmation orient√©e objet pour le
            reproduire en utilisant la programmation fonctionnelle.
        </p>
        <div class="instructions">
            <ol>
                <li>
                    Utilisez des fonctions pures pour g√©rer l'√©tat du jeu.
                </li>
                <li>
                    Utilisez des expressions lambda pour effectuer des traitements sur les tableaux.
                </li>
                <li>
                    Utilisez des fermetures (closures) pour encapsuler les variables de l'environnement.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Exercice - TicTacToe (Bonus)</h3>
        <p>
            Proposez une version am√©lior√©e du jeu du Morpion (Tic-Tac-Toe) en ajoutant la possibilit√© de jouer
            <strong>contre l'ordinateur</strong>.
        </p>
        <p>
            Pour cela, vous pouvez utiliser l'algorithme <strong>Minimax</strong> et la r√©cursivit√© pour que
            l'ordinateur choisisse le meilleur coup √† jouer.
        </p>
        <footer>
            <a href="https://fr.wikipedia.org/wiki/Algorithme_minimax" class="info" target="_blank">Wikip√©dia - Algorithme minimax</a>
        </footer>
    </section>

</section>
