<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UTC 503</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/go.min.js"></script>

    <script>hljs.highlightAll();</script>
    <link rel="stylesheet" href="print.css">
    <link rel="stylesheet" href="print.css">
</head>
<body>

    <section data-background="#002b36" class="first">
    <h1>UTC 503</h1>
    <p>Paradigmes de programmation</p>
</section>
<section id="positioning">

    <section>
        <h2>QCM Positionnement</h2>
    </section>

    <section>
        <h3>Positionnement</h3>
        <p>
            Afin d'évaluer votre niveau en programmation, je vous propose de répondre au questionnaire de positionnement
            suivant :
        </p>
        <p>
            <a href="https://forms.gle/wNPm8y5TQvVMmsUAA" target="_blank">
                Questionnaire de positionnement
            </a>
        </p>
    </section>

</section>
<section id="introduction">

    <section>
        <h2>Paradigmes</h2>
    </section>

    <section>
        <h3>Paradigmes</h3>
        <p>
            En programmation, un <strong>paradigme</strong> est une manière de programmer, c'est-à-dire une façon de
            concevoir et de structurer un programme informatique.
        </p>
        <p>
            Il existe plusieurs paradigmes de programmation, chacun ayant ses propres caractéristiques et ses propres
            avantages. Les principaux paradigmes de programmation sont les suivants :
        </p>
        <ul>
            <li>Impératif</li>
            <li>Déclaratif</li>
            <li>Objet</li>
            <li>Fonctionnel</li>
            <li>Logique</li>
        </ul>
    </section>

    <section>
        <h3>Impératif vs Déclaratif</h3>
        <p>En programmation, il existe deux grandes familles de paradigmes : l'impératif et le déclaratif.</p>
        <p>
            L'impératif est basé sur l'écriture de <strong>séquences d'instructions</strong> qui modifient l'état du
            programme. C'est le cas des langages de programmation orientés objet comme Java, C++, C#, etc.
            C'est également le cas des langages de programmation procéduraux comme C, Pascal, etc.
        </p>
        <p>
            Le déclaratif, quant à lui, est basé sur la <strong>description de ce que l'on veut obtenir</strong>, sans
            se soucier de comment cela sera réalisé. C'est le cas des langages de programmation fonctionnels comme
            Haskell, OCaml, F#, etc ou encore des langages de programmation logiques comme Prolog. D'autres langages
            comme SQL ou CSS sont également déclaratifs.
        </p>
    </section>

    <section>
        <h3>Impératif vs Déclaratif</h3>
        <p>On peut donc représenter des paradigmes avec le schéma suivant :</p>
        <div class="container">
            <div class="col">
                <div class="paradigm paradigm--imperative">
                    <h4>Programmation Impérative</h4>
                    <div class="paradigm">Programmation Orientée Objet</div>
                    <div class="paradigm">Programmation Procédurale</div>
                </div>
            </div>
            <div class="col">
                <div class="paradigm paradigm--declarative">
                    <h4>Programmation Déclarative</h4>
                    <div class="paradigm">Programmation Fonctionnelle</div>
                    <div class="paradigm">Programmation Logique</div>
                </div>
            </div>
        </div>
    </section>

    <section>
        <h3>Langages et paradigmes</h3>
        <p>
            Il est important de noter que la plupart des langages de programmation ne sont pas purement impératifs ou
            déclaratifs. En effet, la plupart des langages de programmation sont des langages <strong>multi-paradigmes</strong>,
            c'est-à-dire qu'ils permettent de programmer de manière impérative, déclarative, objet, fonctionnelle, etc.
        </p>
        <p>
            Par exemple, <strong>Java est un langage de programmation orienté objet</strong>, mais il permet également
            de programmer de manière <strong>impérative et fonctionnelle</strong>.
        </p>
    </section>

    <section>
        <h3>Exemples - Impératif vs Déclaratif</h3>
        <p>
            Pour illustrer la différence entre les paradigmes impératif et déclaratif, prenons un exemple simple : le
            calcul de la somme des éléments d'un tableau.
        </p>
        <p>
            En programmation impérative, on va écrire une boucle qui parcourt le tableau et qui accumule la somme des
            éléments :
        </p>
        <pre><code class="language-java">int sum = 0;
for (int i = 0; i &lt; array.length; i++) {
    sum += array[i];
}
System.out.println(sum);</code></pre>
        <p>
            En programmation déclarative, on va utiliser une fonction qui calcule la somme des éléments du tableau :
        </p>
        <pre><code class="language-java">int sum = Arrays.stream(array).sum();
System.out.println(sum);</code></pre>
        <p>
            Le premier exemple utilise plus précisément le paradigme procédural, tandis que le second exemple utilise
            le paradigme fonctionnel.
        </p>
    </section>

    <section>
        <h3>Exemples - Procédural vs Orientée Objet</h3>
        <p>
            Pour illustrer la différence entre les paradigmes procédural et orienté objet, prenons un exemple simple :
            la modélisation d'un cercle.
        </p>
        <div class="container">
            <div class="col">
                <h4>Procédural</h4>
                <pre><code class="language-c">struct Circle {
    double x, y;
    double radius;
};

double circumference(struct Circle c) {
    return 2 * M_PI * c.radius;
}

double area(struct Circle c) {
    return M_PI * c.radius * c.radius;
}</code></pre>
            </div>
            <div class="col">
                <h4>Orienté Objet</h4>
                <pre><code class="language-java">public class Circle {
    private double x, y;
    private double radius;

    public double circumference() {
        return 2 * Math.PI * radius;
    }

    public double area() {
        return Math.PI * radius * radius;
    }

    // Getters and setters
}</code></pre>
            </div>
        </div>
    </section>

    <section>
        <h3>Autres paradigmes - Programmation concurrente</h3>
        <p>
            La programmation concurrente est un paradigme de programmation qui consiste à exécuter <strong>plusieurs
            tâches en parallèle</strong>, c'est-à-dire en même temps. Cela permet d'optimiser les performances d'un
            programme en utilisant efficacement les ressources matérielles disponibles.
        </p>
        <p>
            Il est possible de programmer de manière concurrente en utilisant des <strong>threads</strong> dans des
            langages de programmation comme Java, C++, Python, etc. ou encore en utilisant des <strong>promesses</strong>
            dans des langages de programmation comme JavaScript.
        </p>
        <footer>
            <a href="https://fr.wikipedia.org/wiki/Programmation_concurrente" class="info" target="_blank">Programmation concurrente</a>
        </footer>
    </section>

    <section>
        <h3>Autres paradigmes - Programmation événementielle</h3>
        <p>
            La programmation événementielle est un paradigme de programmation qui consiste à réagir à des événements
            (clic de souris, pression d'une touche, etc.) en déclenchant des actions associées à ces événements. Cela
            permet de créer des interfaces utilisateur interactives et réactives.
        </p>
        <p>
            Il est possible de programmer de manière événementielle en utilisant des <strong>gestionnaires d'événements</strong>
            dans des langages de programmation comme JavaScript, C#, Java, etc.
        </p>
        <footer>
            <a href="https://fr.wikipedia.org/wiki/Programmation_%C3%A9v%C3%A9nementielle" class="info" target="_blank">Programmation événementielle</a>
        </footer>
    </section>

    <section>
        <h3>Autres paradigmes - Programmation réactive</h3>
        <p>
            La programmation réactive est un paradigme de programmation qui consiste à réagir de manière <strong>asynchrone</strong>
            à des événements en utilisant des <strong>flux de données</strong>. Cela permet de créer des applications
            réactives et interactives.
        </p>
        <p>
            Il est possible de programmer de manière réactive en utilisant des <strong>observables</strong> dans des
            langages de programmation comme JavaScript, Java, C#, etc.
        </p>
        <p>
            Elle est également prépondérante dans le développement d'applications web modernes, notamment avec l'utilisation
            de frameworks comme Angular, React, Vue.js, etc.
        </p>
        <footer>
            <a href="https://fr.wikipedia.org/wiki/Programmation_r%C3%A9active" class="info" target="_blank">Programmation réactive</a>
        </footer>
    </section>

    <section>
        <h3>Paradigme impératif vs réactif</h3>
        <div class="container">
            <div class="col">
                <h4>Impératif</h4>
                <pre><code class="language-c">int a = 1;
int b = 2;
int sum = a + b;

a = 5;

printf("Sum: %d\n", sum); // Sum: 3</code></pre>
            </div>
            <div class="col">
                <h4>Réactif</h4>
                <pre><code class="language-javascript">import { signal, computed } from '@preact/signals-core';

let a = signal(1);
let b = signal(2);
let sum = computed(() => a.value + b.value);

a.value = 5;

console.log(sum.value); // 7</code></pre>
            </div>
        </div>
        <p>
            Il n'existe pas de langage de programmation réactif à proprement parler, mais il est possible de programmer
            de manière réactive en utilisant des bibliothèques et des frameworks qui supportent ce paradigme.
            (ici, on utilise la bibliothèque <code>@preact/signals-core</code> en JavaScript).
        </p>
    </section>

    <section>
        <h3>Pré-requis</h3>
        <p>
            Afin de pouvoir facilement installer les compilateurs et interpréteurs des différents langages de programmation
            présentés dans ce cours, il est recommandé d'utiliser un <strong>gestionnaire de paquets</strong>.
        </p>
        <p>
            Dans ce cours, nous allons utiliser les gestionnaires de paquets suivants :
        </p>
        <ul>
            <li><a href="https://brew.sh" target="_blank" class="info">Homebrew</a> pour macOS</li>
            <li><a href="https://scoop.sh" target="_blank" class="info">Scoop</a> pour Windows</li>
        </ul>
    </section>

</section>
<section id="procedural">

    <section>
        <h2>Paradigme Procédural</h2>
    </section>

    <section>
        <h3>Rappels</h3>
        <p>
            Nous allons dans un premier temps faire quelques
            <strong>rappels sur les bases de la programmation procédurale</strong>.
        </p>
        <p>
            Pour cela, nous allons utiliser le langage <strong>C</strong> qui est un langage de programmation
            <strong>procédural</strong> et qui a influencé de nombreux autres langages comme le C++, le Java ou le JavaScript.
        </p>
        <img src="assets/images/c.png" alt="Logo du langage C">
    </section>

    <section>
        <h3>Langage C</h3>
        <p>
            Le langage C est un langage de programmation impératif, procédural et structuré.
        </p>
        <p>
            Il a été créé en 1972 par Dennis Ritchie et est toujours très utilisé aujourd'hui.
        </p>
        <p>
            Afin d'écrire des programmes en C, il est nécessaire de disposer d'un compilateur comme <strong>gcc</strong>
            que nous allons installer sur notre machine :
        </p>
        <div class="container">
            <div class="col">
                <h4>macOS</h4>
                <pre class="language-bash"><code>brew install gcc</code></pre>
            </div>
            <div class="col">
                <h4>Windows</h4>
                <pre class="language-bash"><code>scoop install gcc</code></pre>
            </div>
        </div>
    </section>

    <section>
        <h3>Exemple</h3>
        <p>
            Voici un exemple de programme en C qui affiche un message à l'écran :
        </p>
        <pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf("Hello, World!\n");
    return 0;
}</code></pre>
        <p>
            Pour compiler et exécuter ce programme, il suffit de taper les commandes suivantes dans un terminal :
        </p>
        <pre><code class="language-shell">gcc hello.c -o hello
./hello</code></pre>
    </section>

    <section>
        <h3>Variables</h3>
        <p>
            Les variables sont des emplacements de mémoire qui permettent de stocker des valeurs.
        </p>
        <p>
            En C, il est nécessaire de déclarer le type d'une variable avant de l'utiliser :
        </p>
        <pre><code class="language-c">int age = 42;
float price = 3.14;
char letter = 'A';</code></pre>
        <p>
            Il existe différents types de variables en C comme les <strong>entiers</strong>, les <strong>flottants</strong> ou les <strong>caractères</strong>.
        </p>
        <p>
            Le langage C utilise le <strong>typage statique</strong>, ce qui signifie que le type des variables doit
            être déclaré explicitement contraitement à des langages comme JavaScript ou Python qui utilisent le
            <strong>typage dynamique</strong>.
        </p>
    </section>

    <section>
        <h3>Lecture / Écriture</h3>
        <p>
            Nous pouvons lire et écrire des valeurs à l'écran en utilisant les fonctions <code>scanf()</code> et
            <code>printf()</code> :
        </p>
        <pre><code class="language-c">int age;
printf("Quel âge avez-vous ? ");
scanf("%d", &age);
printf("Vous avez %d ans.\n", age);</code></pre>
        <p>
            Il est important de noter que la fonction <code>scanf()</code> utilise le symbole <code>&</code> pour
            récupérer l'adresse mémoire de la variable <code>age</code>.
        </p>
        <p>
            Cela est dû au fait que les paramètres de la fonction <code>scanf()</code> sont passés par référence
            contrairement à la fonction <code>printf()</code> qui les passe par valeur.
        </p>
        <p>
            Dans les deux cas, il est nécessaire de préciser le type de la variable à l'aide de symboles comme
            <code>%d</code> pour les entiers, <code>%f</code> pour les flottants, <code>%c</code> pour les caractères...
        </p>
        <footer>
            <a href="https://en.wikipedia.org/wiki/C_data_types" class="info" target="_blank">
                Types de données en C
            </a>
        </footer>
    </section>

    <section>
        <h3>Conditions</h3>
        <p>
            Les structures de contrôle permettent de contrôler le flux d'exécution d'un programme.
        </p>
        <p>
            En C, on retrouve les structures de contrôle classiques comme les <strong>conditions</strong> et les <strong>boucles</strong> :
        </p>
        <pre><code class="language-c">if (age &gt;= 18) {
    printf("Vous êtes majeur.\n");
} else {
    printf("Vous êtes mineur.\n");
}</code></pre>
    </section>

    <section>
        <h3>Boucles</h3>
        <p>
            Les boucles permettent de répéter des instructions un certain nombre de fois.
        </p>
        <p>
            En C, on retrouve les boucles <strong>while</strong>, <strong>do...while</strong> et <strong>for</strong> :
        </p>
        <pre><code class="language-c">int i = 0;
while (i &lt; 10) {
    printf("%d\n", i);
    i++;
}</code></pre>
        <pre><code class="language-c">int j = 0;
do {
    printf("%d\n", j);
    j++;
} while (j &lt; 10);</code></pre>
        <pre><code class="language-c">for (int k = 0; k &lt; 10; k++) {
    printf("%d\n", k);
}</code></pre>
    </section>

    <section>
        <h3>Exercice - Plus ou moins</h3>
        <p>
            Nous allons maintenant mettre en pratique les notions que nous venons de voir avec un exercice.
        </p>
        <p>
            L'objectif est d'écrire un programme en C qui génère un nombre aléatoire entre 1 et 100 et qui demande à
            l'utilisateur de deviner ce nombre.
        </p>
        <p>
            Le programme doit afficher "Plus" si le nombre à deviner est plus grand que celui proposé par l'utilisateur,
            "Moins" s'il est plus petit et "Bravo !" s'il est égal.
        </p>
        <p>
            Vous pouvez utiliser la fonction <code>rand()</code> pour générer un nombre aléatoire et la fonction
            <code>scanf()</code> pour lire l'entrée de l'utilisateur.
        </p>
    </section>

    <section>
        <h3>Exercice - Plus ou moins (avancé)</h3>
        <p>
            Pour les plus avancés, vous pouvez améliorer le programme précédent en ajoutant les fonctionnalités
            suivantes :
        </p>
        <div class="instructions">
            <ol>
                <li>
                    Afficher le nombre de tentatives à chaque essai.
                </li>
                <li>
                    Ajouter un timer pour limiter le temps de jeu (30 secondes).
                </li>
                <li>
                    Afficher le nombre à deviner à la fin du jeu si l'utilisateur n'a pas trouvé.
                </li>
                <li>
                    Ajouter un niveau de difficulté (facile, moyen, difficile) qui influe sur la plage de nombres à deviner.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Tableaux</h3>
        <p>
            Les tableaux permettent de stocker plusieurs valeurs dans une seule variable.
        </p>
        <p>
            En C, les tableaux sont des collections de valeurs de même type qui sont stockées de manière contiguë en mémoire.
        </p>
        <pre><code class="language-c">int numbers[5] = {1, 2, 3, 4, 5};</code></pre>
        <p>
            Il est possible d'accéder à un élément d'un tableau en utilisant son indice :
        </p>
        <pre><code class="language-c">printf("%d\n", numbers[0]);</code></pre>
    </section>

    <section>
        <h3>Tableaux dynamiques</h3>
        <p>
            En C, les tableaux sont de taille fixe, ce qui signifie qu'il est nécessaire de définir leur taille à la compilation.
        </p>
        <p>
            Pour pallier à ce problème, il est possible d'utiliser des pointeurs pour allouer dynamiquement de la mémoire :
        </p>
        <pre><code class="language-c">int *numbers;
int size;
printf("Quelle taille pour le tableau ? ");
scanf("%d", &size);
numbers = (int *)malloc(size * sizeof(int));</code></pre>
        <p>
            La fonction <code>malloc()</code> permet d'allouer de la mémoire pour un tableau de <code>size</code> entiers.
        </p>
        <p>
            Il est important de libérer la mémoire allouée à l'aide de la fonction <code>free()</code> pour éviter les fuites de mémoire :
        </p>
        <pre><code class="language-c">free(numbers);</code></pre>
    </section>

    <section>
        <h3>Fonctions</h3>
        <p>
            Les fonctions permettent de regrouper des instructions pour les réutiliser plus facilement.
        </p>
        <p>
            En C, une fonction est définie par son type de retour, son nom et ses paramètres :
        </p>
        <pre><code class="language-c">int add(int a, int b) {
    return a + b;
}</code></pre>
        <p>
            Il est possible de déclarer une fonction avant de l'utiliser pour éviter les erreurs de compilation :
        </p>
        <pre><code class="language-c">int add(int a, int b);</code></pre>
        <p>
            On appelle cela un <strong>prototype de fonction</strong>.
        </p>
    </section>

    <section>
        <h3>Exercice - Somme de 2 nombres</h3>
        <p>
            À partir d'un tableau de nombres et d'un nombre cible, écrire un algorithme qui détermine si deux nombres du tableau
            peuvent être additionnés pour obtenir le nombre cible et retourner les indices de ces deux nombres.
        </p>
        <p>
            Par exemple, si le tableau contient les valeurs <code>2, 7, 11, 15</code> et que le nombre cible est <code>9</code>,
            alors l'algorithme doit retourner les indices <code>0</code> et <code>1</code> car <code>2 + 7 = 9</code>.
        </p>
        <p>
            Autre exemple, si le tableau contient les valeurs <code>3, 2, 4</code> et que le nombre cible est <code>6</code>,
            alors l'algorithme doit retourner les indices <code>1</code> et <code>2</code> car <code>2 + 4 = 6</code>.
        </p>
    </section>

    <section>
        <h3>Exercice - Somme de 2 nombres</h3>
        <div class="instructions">
            <ol>
                <li>
                    Créer un tableau de nombres et un nombre cible.
                </li>
                <li>
                    Parcourir le tableau et essayez de trouver deux éléments qui peuvent être additionnés pour obtenir le nombre cible.
                </li>
                <li>
                    Si c'est le cas, afficher les indices des deux éléments.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Exercice - Somme de 2 nombres (avancée)</h3>
        <div class="instructions">
            <ol>
                <li>
                    Demandez à l'utilisateur de saisir les valeurs du tableau et le nombre cible.
                </li>
                <li>
                    Essayer d'optimiser l'algorithme pour qu'il soit le plus rapide possible.
                </li>
            </ol>
        </div>
    </section>

</section>
<section id="object">

    <section>
        <h2>Paradigme Objet</h2>
    </section>

    <section>
        <h3>Historique</h3>
        <p>
            Le <strong>paradigme objet</strong> est apparu dans les années 1960 avec le langage de programmation Simula.
            Il a été popularisé dans les années 1980 avec l'arrivée de langages de programmation orientés objet comme
            Smalltalk, C++ et Java.
        </p>
    </section>

    <section>
        <h3>Java</h3>
        <p>
            Afin d'illustrer les concepts de la programmation orientée objet, nous allons utiliser le langage Java.
        </p>
        <p>
            Java est un langage de programmation de haut niveau, compilé et orienté objet. Il a été créé en 1995 par Sun
            Microsystems et est toujours très utilisé aujourd'hui.
        </p>
        <p>
            Pour écrire et exécuter du code Java, il est nécessaire d'installer le <strong>JDK</strong> (Java Development Kit)
            sur votre machine. Voici les commandes à taper dans un terminal pour installer le JDK :
        </p>
        <div class="container">
            <div class="col">
                <h4>macOS</h4>
                <pre class="language-bash"><code>brew install openjdk</code></pre>
            </div>
            <div class="col">
                <h4>Windows</h4>
                <pre class="language-bash"><code>scoop bucket add java
scoop install openjdk</code></pre>
            </div>
        </div>
    </section>

    <section>
        <h3>Hello world</h3>
        <p>
            Voici un exemple de programme Java qui affiche un message à l'écran :
        </p>
        <pre><code class="language-java">public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}</code></pre>
        <p>
            Comme pour le langage C, la méthode <code class="language-java">main()</code> est le point d'entrée du programme Java.
        </p>
        <p>
            Pour compiler et exécuter ce programme, il suffit de taper les commandes suivantes dans un terminal :
        </p>
        <pre><code class="language-shell">javac HelloWorld.java</code></pre>
        <pre><code class="language-shell">java HelloWorld</code></pre>
        <p>
            Sur VSCode, vous pouvez également
            <a href="https://code.visualstudio.com/docs/java/java-tutorial#_creating-a-source-code-file" target="_blank">créer un nouveau projet</a>
            Java en utilisant la palette de commande (Ctrl + Shift + P) et en tapant "Java: Create Java Project".
        </p>
    </section>

    <section>
        <h3>Classes et objets</h3>
        <p>
            En POO, un <strong>objet</strong> est une instance d'une <strong>classe</strong>.
            Une classe est un modèle qui définit les <strong>attributs</strong> (ou propriétés) et les
            <strong>méthodes</strong> (fonctions) communs à tous les objets de cette classe.
        </p>
        <p>
            Par exemple, une classe <code class="language-java">Circle</code> peut avoir des attributs comme le rayon
            et des méthodes comme le calcul de la circonférence et de l'aire du cercle :
        </p>
        <pre><code class="language-java">public class Circle {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    public double circumference() {
        return 2 * Math.PI * this.radius;
    }

    public double area() {
        return Math.PI * this.radius * this.radius;
    }
}</code></pre>
    </section>

    <section>
        <h3>Packages</h3>
        <p>
            Un <strong>package</strong> est un regroupement logique de classes et d'interfaces en Java.
            Il permet d'organiser et de structurer le code source en modules réutilisables.
        </p>
        <p>
            Pour créer un package, il suffit de déclarer le nom du package en haut du fichier Java :
        </p>
        <pre><code class="language-java">package com.mycompany.shapes;</code></pre>
        <p>
            Par convention, le nom d'un package est en minuscules et correspond à l'arborescence des répertoires.
        </p>
        <p>
            Nous allons donc positionner la classe <code class="language-java">Circle</code> dans le dossier
            <code class="language-shell">src/main/java/com/mycompany/shapes/Circle.java</code>.
        </p>
        <footer>
            <a href="https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html" class="info" target="_blank">
                Maven - Structure standard des répertoires
            </a>
            <a href="https://code.visualstudio.com/docs/java/java-project#_configure-classpath-for-unmanaged-folders" class="info" target="_blank">
                VS Code - Configurer le classpath
            </a>
        </footer>
    </section>

    <section>
        <h3>Constructeurs</h3>
        <p>
            Un <strong>constructeur</strong> est une méthode spéciale d'une classe qui est appelée lors de la création
            d'un objet. Il permet d'initialiser les attributs de l'objet avec des valeurs par défaut.
        </p>
        <p>
            En Java, un constructeur a le même nom que la classe et ne renvoie pas de valeur. Il peut être surchargé
            avec des paramètres différents pour initialiser les attributs de l'objet :
        </p>
        <pre><code class="language-java">public class Circle {
    private double radius;

    public Circle() { // Constructeur par défaut
        this.radius = 5;
    }

    public Circle(double radius) { // Constructeur avec paramètre
        this.radius = radius;
    }
}</code></pre>
    </section>

    <section>
        <h3>Encapsulation</h3>
        <p>
            L'<strong>encapsulation</strong> est un principe de la programmation orientée objet qui consiste à regrouper
            les données (attributs) et les méthodes qui les manipulent au sein d'une même classe.
        </p>
        <p>
            En Java, l'encapsulation est réalisée en déclarant les attributs d'une classe comme <code>private</code>
            et en fournissant des méthodes publiques pour y accéder (getters) et les modifier (setters) :
        </p>
        <pre><code class="language-java">public class Circle {
    private double radius;

    public double getRadius() {
        return radius;
    }

    public void setRadius(double radius) {
        this.radius = radius;
    }
}</code></pre>
    </section>

    <section>
        <h3>Exercice - Librairie Video</h3>
        <p>
            Pour la suite de ce cours, nous allons <strong>créer une librairie</strong> permettant d'afficher sur une
            page web un <strong>lecteur vidéo</strong>.
        </p>
        <p>
            Notre librairie permettra ainsi <strong>à partir de l'URL</strong> d'une vidéo de générer le code HTML
            nécessaire pour afficher le lecteur vidéo.
        </p>
        <div class="container">
            <div class="col" style="flex: 2">
                <div class="instructions">
                    <ol>
                        <li>
                            Créez une classe <code>Video</code>.
                        </li>
                        <li>
                            Ajoutez avec un attribut <code>url</code>.
                        </li>
                        <li>
                            Ajoutez des méthodes pour <code>get</code> et <code>set</code> l'attribut <code>url</code>.
                        </li>
                        <li>
                            Modifiez le constructeur pour obliger à initialiser l'attribut <code>url</code>.
                        </li>
                    </ol>
                </div>
            </div>
            <div class="col">
                <a href="assets/images/oop/step1.png" target="_blank">
                    <img src="assets/images/oop/step1.png" alt="Video class diagram - step 1">
                </a>
            </div>
        </div>
    </section>

    <section>
        <h3>Héritage</h3>
        <p>
            L'<strong>héritage</strong> est un mécanisme de la programmation orientée objet qui permet à une classe
            (appelée <strong>classe fille</strong>) d'hériter des attributs et des méthodes d'une autre classe
            (appelée <strong>classe mère</strong>).
        </p>
        <p>
            En Java, l'héritage est réalisé à l'aide du mot-clé <code class="language-java">extends</code> :
        </p>
        <pre><code class="language-java">public class Circle extends Shape {
    // Attributs et méthodes de la classe Shape
}</code></pre>
    </section>

    <section>
        <h3>Exercice - Librairie Video</h3>
        <div class="container">
            <div class="col" style="flex: 2">
                <div class="instructions">
                    <ol>
                        <li>
                            Créez deux classes <code>YouTube</code> et <code>Vimeo</code> qui héritent de la classe <code>Video</code>.
                        </li>
                        <li>
                            Ajoutez une méthode <code>getCode()</code> à la classe <code>YouTube</code>.
                        </li>
                        <li>
                            Ajoutez une propriété <code>color</code> avec ses méthodes <code>get</code> et <code>set</code> à la classe <code>Vimeo</code>.
                        </li>
                        <li>
                            Ajoutez une méthode <code>getHTML()</code> aux classes <code>YouTube</code> et <code>Vimeo</code>.
                        </li>
                    </ol>
                </div>
            </div>
            <div class="col">
                <a href="assets/images/oop/step2.png" target="_blank">
                    <img src="assets/images/oop/step2.png" alt="Video class diagram - step 2">
                </a>
            </div>
        </div>
    </section>

    <section>
        <h3>Abstraction</h3>
        <p>
            L'<strong>abstraction</strong> est un principe de la programmation orientée objet qui consiste à cacher les
            détails d'implémentation d'une classe pour ne montrer que les fonctionnalités essentielles.
        </p>
        <p>
            En Java, l'abstraction est réalisée à l'aide de <strong>classes abstraites</strong>
            et d'<strong>interfaces</strong>.
        </p>
    </section>

    <section>
        <h3>Classes abstraites</h3>
        <p>
            Une <strong>classe abstraite</strong> est une classe qui ne peut pas être instanciée et qui peut contenir
            des méthodes abstraites (sans corps) qui doivent être implémentées par les classes filles.
        </p>
        <pre><code class="language-java">public abstract class Shape {
    public abstract double area();
}</code></pre>
        <p>
            Cette classe ne pourra pas être instanciée, mais servira de modèle pour les classes filles qui devront
            implémenter la méthode <code class="language-java">area()</code>.
        </p>
    </section>

    <section>
        <h3>Exercice - Librairie Video</h3>
        <div class="container">
            <div class="col" style="flex: 2">
                <div class="instructions">
                    <ol>
                        <li>
                            Modifiez la classe <code>Video</code> pour en faire une classe abstraite.
                        </li>
                        <li>
                            Ajoutez une méthode abstraite <code>getHTML()</code> à la classe <code>Video</code>.
                        </li>
                    </ol>
                </div>
            </div>
            <div class="col">
                <a href="assets/images/oop/step3.png" target="_blank">
                    <img src="assets/images/oop/step3.png" alt="Video class diagram - step 3">
                </a>
            </div>
        </div>
    </section>

    <section>
        <h3>Interfaces</h3>
        <p>
            Une <strong>interface</strong> est un contrat qui définit les méthodes qu'une classe doit implémenter.
            En Java, une classe peut implémenter plusieurs interfaces, mais ne peut hériter que d'une seule classe.
        </p>
        <pre><code class="language-java">public interface Drawable {
    void draw();
    void fill();
    void erase();
}</code></pre>
        <p>
            Une classe qui implémente une interface doit fournir une implémentation pour toutes les méthodes de l'interface.
        </p>
    </section>

    <section>
        <h3>Polymorphisme</h3>
        <p>
            Le <strong>polymorphisme</strong> est un concept de la programmation orientée objet qui permet à un objet
            d'adopter plusieurs formes. Cela signifie qu'un objet peut être traité comme un objet de sa classe ou comme
            un objet de sa classe parente ou d'une interface qu'il implémente.
        </p>
        <p>
            On pourrait par exemple avoir un tableau d'objets de type <code>Shape</code> qui contient des objets de type
            <code>Circle</code>, <code>Rectangle</code> ou <code>Triangle</code>:
        </p>
        <pre><code class="language-java">Shape[] shapes = new Shape[3];
shapes[0] = new Circle(5);
shapes[1] = new Rectangle(10, 20);
shapes[2] = new Triangle(3, 4, 5);

for (Shape shape : shapes) {
    System.out.println(shape.area());
}</code></pre>
    </section>

    <section>
        <h3>Exercice - Librairie Video</h3>
        <div class="container">
            <div class="col" style="flex: 2">
                <div class="instructions">
                    <ol>
                        <li>
                            Créez une interface <code>Media</code> avec une méthode <code>getUrl()</code>.
                        </li>
                        <li>
                            Modifiez la classe <code>Video</code> pour qu'elle implémente l'interface <code>Media</code>.
                        </li>
                        <li>
                            Créez une classe <code>Player</code> qui prend en paramètre un objet <code>Media</code>
                            avec une méthode <code>play()</code> qui permet d'exécuter le média.
                        </li>
                    </ol>
                </div>
            </div>
            <div class="col">
                <a href="assets/images/oop/step4.png" target="_blank">
                    <img src="assets/images/oop/step4.png" alt="Video class diagram - step 4">
                </a>
            </div>
        </div>
    </section>

    <section>
        <h3>Exercice - Librairie Video</h3>
        <div class="instructions">
            <ol>
                <li>
                    Créer une nouvelle classe DailyMotion.
                </li>
                <li>
                    Créer une classe <code>Audio</code> qui soit compatible avec la classe <code>Player</code>.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Duck Typing</h3>
        <p>
            Le <strong>duck typing</strong> est un concept de programmation objet qui consiste à vérifier la présence de
            méthodes ou d'attributs sur un objet plutôt que de vérifier son type. En d'autres termes, si un objet se comporte
            comme un canard (c'est-à-dire qu'il a une méthode <code>quack()</code>), alors on peut le considérer comme un canard.
        </p>
        <p>
            Certains langages de programmation orientés objet, comme Python et Ruby utilisent le duck typing.
            Cependant, des langages comme Java, C# ou C++ utilisent un typage statique, ce qui signifie que le type
            d'un objet doit être déclaré explicitement.
        </p>
        <footer>
            <a href="https://fr.wikipedia.org/wiki/Duck_typing" target="_blank" class="info">Duck typing</a>
        </footer>
    </section>

    <section>
        <h3>Duck Typing en Python</h3>
        <pre><code class="language-python">class Duck:
    def quack(self):
        print("Quack!")

class Person:
    def quack(self):
        print("I'm quacking like a duck!")

def make_it_quack(obj):
    obj.quack()

donald = Duck()
alice = Person()

make_it_quack(donald)  # Output: Quack!
make_it_quack(alice)   # Output: I'm quacking like a duck!</code></pre>
    </section>

    <section>
        <h3>Généricité</h3>
        <p>
            La <strong>généricité</strong> est un concept de programmation qui permet de créer des classes, des interfaces
            ou des méthodes qui peuvent fonctionner avec différents types de données sans être spécifiques à un type particulier.
        </p>
        <p>
            En Java, la généricité est réalisée à l'aide de <strong>types paramétrés</strong> (ou generics) :
        </p>
        <div class="container">
            <div class="col">
                <pre><code class="language-java">public class Box&lt;T&gt; {
    private T value;

    public Box(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}</code></pre>
            </div>
            <div class="col">
                <pre><code class="language-java">Box&lt;String&gt; box1 = new Box&lt;String&gt;("Hello, World!");
Box&lt;Integer&gt; box2 = new Box&lt;Integer&gt;(42);

String value1 = box1.getValue();
Integer value2 = box2.getValue();</code></pre>
            </div>
        </div>
        <footer>
            <a href="https://fr.wikipedia.org/wiki/G%C3%A9n%C3%A9ricit%C3%A9" target="_blank" class="info">Généricité</a>
        </footer>
    </section>

    <section>
        <h3>Généricité - Exemples</h3>
        <p>
            En JAVA, la généricité est régulièrement utilisée pour les collections :
        </p>
        <pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;String&gt;();
list.add("Hello");
list.add("World");

for (String item : list) {
    System.out.println(item);
}</code></pre>
        <p>
            On peut également utiliser la généricité pour les classes abstraites et les interfaces :
        </p>
        <pre><code class="language-java">public interface List&lt;T&gt; {
    void add(T item);
    T get(int index);
}</code></pre>
    </section>

    <section>
        <h3>Reflection</h3>
        <p>
            La <strong>reflection</strong> est un mécanisme qui permet à un programme de s'analyser lui-même et d'interagir
            avec ses propres structures internes (classes, méthodes, attributs, etc.).
        </p>
        <p>
            On peut distinguer deux techniques de réflexion :
        </p>
        <ul>
            <li>
                <strong>Introspection</strong> : permet de connaître les propriétés et les méthodes d'un objet à l'exécution.
            </li>
            <li>
                <strong>Intercession</strong> : permet de modifier les propriétés et les méthodes d'un objet à l'exécution.
            </li>
        </ul>
        <footer>
            <a href="https://fr.wikipedia.org/wiki/R%C3%A9flexion_(informatique)" target="_blank" class="info">Reflection</a>
        </footer>
    </section>

    <section>
        <h3>Introspection en Java</h3>
        <p>
            En Java, l'introspection est réalisée à l'aide de la classe <code>Class</code> qui permet d'obtenir des informations
            sur une classe à l'exécution :
        </p>
        <pre><code class="language-java">public class ReflectionExample {
    public static void main(String[] args) {
        Class&lt;?&gt; stringClass = String.class;

        System.out.println("Nom de la classe : " + stringClass.getName()); // java.lang.String
        System.out.println("Package de la classe : " + stringClass.getPackage()); // package java.lang
        System.out.println("Méthodes de la classe : " + Arrays.toString(stringClass.getMethods())); // [toString, hashCode, equals, ...]
    }
}</code></pre>
    </section>

    <section>
        <h3>Intercession en Java</h3>
        <p>
            En Java, l'intercession permet d'appeler des méthodes et de modifier des attributs d'un objet à l'exécution :
        </p>
        <pre><code class="language-java">public class ReflectionExample {
    public static void main(String[] args) throws Exception {
        Class&lt;?&gt; stringClass = String.class;
        Object obj = stringClass.getConstructor(String.class).newInstance("Hello, World!");

        Method method = stringClass.getMethod("toUpperCase");
        String result = (String) method.invoke(obj);

        System.out.println(result);
    }
}</code></pre>
    </section>

    <section>
        <h3>Réflexion - Exercice Service Container</h3>
        <p>
            Créez un <strong>Service Container</strong> en Java qui permet d'enregistrer des services et de les récupérer
            à l'aide de leur nom.
        </p>
        <p>
            Un service est une instance d'une classe que l'on peut enregistrer dans le container avec une clé (nom) et
            récupérer à l'aide de cette clé.
        </p>
        <p>
            Voici l'interface que l'on utilisera pour créer le Service Container :
        </p>
        <pre><code class="language-java">public interface ServiceContainerInterface {
    public &lt;T&gt; T registerService(T service);
    public &lt;T&gt; T getService(Class&lt;T&gt; serviceClass) throws Exception;
}</code></pre>
        <p>
            La méthode <code class="language-java">getService()</code> fera appel à la réflexion pour instancier un
            service si celui-ci n'est pas déjà enregistré dans le container.
        </p>
    </section>

    <section>
        <h3>Exercice - TicTacToe</h3>
        <p>
            Créez un jeu de <strong>Morpion</strong> (Tic Tac Toe) en Java qui permet à deux joueurs de s'affronter.
        </p>
        <p>
            Les joueurs pourront jouer à tour de rôle en choisissant une case vide du plateau de jeu (les cases
            seront numérotées de 1 à 9).
        </p>
        <p>
            Le jeu se terminera lorsqu'un joueur aura aligné trois symboles (X ou O) horizontalement, verticalement
            ou diagonalement ou bien lorsque toutes les cases du plateau seront remplies.
        </p>
        <p>
            Votre code devra être organisé de manière à respecter les principes de la programmation orientée objet.
        </p>
        <p>
            De plus, le code devra être évolutif et permettre de facilement créer un jeu de puissance 4 par exemple.
        </p>
        <div class="instructions">
            <ol>
                <li>
                    Créer un diagramme de classes pour modéliser le jeu de Morpion.
                </li>
                <li>
                    Développer le jeu à partir de ce diagramme.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Exercice avancé - Pattern Adapter 🦃 -> 🦆</h3>
        <p>
            Utilisez le design pattern Adapter afin de contourner l'absence de duck typing en Java.
        </p>
        <div class="instructions">
            <ol>
                <li>
                    Créez une interface <code>Duck</code> avec une méthode <code>quack()</code>.
                </li>
                <li>
                    Créez une classe <code>MallardDuck</code> 🦆 qui implémente l'interface <code>Duck</code>.
                </li>
                <li>
                    Créez une classe <code>Turkey</code> 🦃 avec une méthode <code>gobble()</code>.
                </li>
                <li>
                    Créez une classe <code>TurkeyAdapter</code> qui implémente l'interface <code>Duck</code> et qui utilise un objet <code>Turkey</code> pour adapter les méthodes <code>quack()</code> et <code>gobble()</code>.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Exercice avancé - Pattern Observer</h3>
        <p>
            Utilisez le design pattern Observer pour créer un système de notifications.
        </p>
        <div class="instructions">
            <ol>
                <li>
                    Créez une interface <code>Observer</code> avec une méthode <code>update()</code>.
                </li>
                <li>
                    Créez une interface <code>Subject</code> avec des méthodes pour ajouter, supprimer et notifier les observateurs.
                </li>
                <li>
                    Créez une classe <code>NotificationSystem</code> qui implémente l'interface <code>Subject</code>.
                </li>
                <li>
                    Créez une classe <code>Notification</code> qui implémente l'interface <code>Observer</code>.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Exercice avancé - Pattern Composite</h3>
        <p>
            Utilisez le design pattern Composite pour créer un système de gestion de fichiers / dossiers.
        </p>
        <div class="instructions">
            <ol>
                <li>
                    Créez une interface <code>FileComponent</code> avec des méthodes pour afficher le nom et la taille d'un fichier ou d'un dossier.
                </li>
                <li>
                    Créez une classe <code>File</code> qui implémente l'interface <code>FileComponent</code>.
                </li>
                <li>
                    Créez une classe <code>Folder</code> qui implémente l'interface <code>FileComponent</code> et qui contient une liste de fichiers et de dossiers.
                </li>
            </ol>
        </div>
    </section>

</section>
<section id="functional">

    <section>
        <h2>Paradigme Fonctionnel</h2>
    </section>

    <section>
        <h3>Programmation fonctionnelle</h3>
        <p>
            La programmation fonctionnelle est un <strong>paradigme de programmation</strong> qui considère le calcul
            comme l'évaluation de fonctions mathématiques et évite les changements d'état et les données mutables.
        </p>
        <p>
            Les langages de programmation fonctionnelle sont basés sur les concepts de fonctions pures, d'immuabilité et de récursivité.
        </p>
    </section>

    <section>
        <h3>Languages fonctionnels</h3>
        <ul>
            <li>
                <a href="https://www.haskell.org/" target="_blank">Haskell</a> :
                langage de programmation fonctionnel pur, créé en 1990. Ce langage essai de respecter le plus possible
                les principes de la programmation fonctionnelle.
            </li>
            <li>
                <a href="https://fsharp.org/" target="_blank">F#</a> :
                langage de programmation fonctionnel impératif, créé en 2005 par Microsoft. Il est utilisé pour le
                développement d'applications web, mobiles et cloud.
            </li>
            <li>
                <a href="https://www.erlang.org/" target="_blank">Erlang</a> :
                langage de programmation fonctionnel concurrent, créé en 1986 par la société Ericsson. Il est utilisé
                pour le développement de systèmes distribués et tolérants aux pannes (let it crash).
            </li>
            <li>
                <a href="https://www.scala-lang.org/" target="_blank">Scala</a> :
                langage de programmation fonctionnel et orienté objet, créé en 2003. Il est basé sur la machine virtuelle
                Java et permet de combiner les avantages de la programmation fonctionnelle et de la programmation orientée objet.
            </li>
        </ul>
        <p>
            Par la suite, nous aborderons quelques examples de programmation fonctionnelle Haskell que vous pourrez
            exécuter directement dans votre navigateur (<a href="https://play.haskell.org/">https://play.haskell.org/</a>).
        </p>
    </section>

    <section>
        <h3>JavaScript</h3>
        <p>
            JavaScript est un langage de programmation de haut niveau, interprété, multi-paradigme.
        </p>
        <p>
            Il s'agit initialement d'un <strong>langage de script pour les pages web</strong>, mais il est également
            utilisé pour programmer des serveurs, des applications mobiles et des jeux vidéo...
        </p>
        <p>
            Nous allons utiliser ensemble Node.js pour exécuter du code JavaScript en mode console.
        </p>
        <p>
            Voici les commandes à taper dans un terminal pour installer Node.js et npm :
        </p>
        <div class="container">
            <div class="col">
                <h4>macOS</h4>
                <pre><code class="language-bash">brew install node</code></pre>
            </div>
            <div class="col">
                <h4>Windows</h4>
                <pre><code class="language-bash">scoop install nodejs</code></pre>
            </div>
        </div>
    </section>

    <section>
        <h3>Node.js</h3>
        <p>
            Node.js est un environnement d'exécution <strong>JavaScript côté serveur</strong>,
            basé sur le moteur JavaScript V8 de Google.
        </p>
        <p>
            Il permet d'exécuter du code JavaScript en dehors d'un navigateur web, et d'interagir avec le système
            d'exploitation.
        </p>
        <p>
            Pour créer un projet Node.js, il suffit de créer un fichier <code>index.js</code>
            et d'y écrire du code JavaScript :
        </p>
        <pre><code class="language-js">console.log('Hello, World!');</code></pre>
        <p>
            Pour exécuter ce code, il suffit de taper la commande suivante dans un terminal :
        </p>
        <pre><code class="language-bash">node index.js</code></pre>
    </section>

    <section>
        <h3>Fonctions pures</h3>
        <p>
            Une fonction pure est une fonction qui, pour une entrée donnée, retourne
            <strong>toujours la même sortie</strong> et n'a <strong>pas d'effets de bord</strong>.
        </p>
        <p>
            Un contre-exemple en JavaScript est la fonction <code class="language-js">sort()</code> qui modifie l'ordre
            des éléments d'un tableau au lieu de retourner un nouveau tableau trié comme le ferait une fonction pure
            telle que <code class="language-js">filter()</code>.
        </p>
        <pre><code class="language-js">const arr = [3, 1, 2];
arr.sort(); // Cette fonction va modifier la variable arr
console.log(arr); // [1, 2, 3]
arr.filter(function (x) { return x > 1; }); // Cette fonction ne va pas modifier arr mais retourner un nouveau tableau
console.log(arr); // [1, 2, 3]</code></pre>
        <p>
            La fonction <code class="language-js">sort()</code> est un exemple de fonction impure, car elle modifie
            l'état global du tableau <code class="language-js">arr</code> et a donc un effet de bord.
        </p>
        <footer>
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted" class="info">
                MDN Web Docs - Array.prototype.toSorted()
            </a>
        </footer>
    </section>

    <section>
        <h3>Fonctions pures</h3>
        <p>
            Dans l'exemple ci-dessous, la fonction <code class="language-js">calculateAge</code> n'est pas une fonction
            pure, car elle utilise la date actuelle pour calculer l'âge de l'utilisateur.
        </p>
        <pre><code class="language-js">function calculateAge(birthDate) {
    const now = new Date(); // Ne retourne pas toujours la même valeur
    const diff = now - birthDate;
    const age = Math.floor(diff / (1000 * 60 * 60 * 24 * 365.25));
    return age;
}</code></pre>
        <p>
            Pour rendre cette fonction pure, il faudrait passer la date actuelle en paramètre.
        </p>
    </section>

    <section>
        <h3>Fonctions pures</h3>
        <p>
            Les fonctions pures ont plusieurs avantages :
        </p>
        <ul>
            <li>
                Elles sont plus faciles à <strong>tester</strong>.<br>
                Dans l'exemple précédent, il est difficile de tester la fonction
                <code class="language-js">calculateAge()</code> car elle dépend de la date actuelle et le résultat du
                test variera en fonction de la date d'exécution.
            </li>
            <li>
                Elles sont plus faciles à <strong>comprendre</strong>.<br>
                Les fonctions pures sont auto-documentées, car elles ne dépendent que de leurs paramètres d'entrée.
            </li>
            <li>
                Elles sont plus faciles à <strong>paralléliser</strong>.<br>
                Les fonctions pures peuvent être exécutées en parallèle sans risque de conflits de données, car elles
                n'ont pas d'effets de bord comme par exemple la modification d'une variable globale.
            </li>
            <li>
                Elles sont plus faciles à <strong>optimiser</strong>.<br>
                Les fonctions pures peuvent être mises en cache pour éviter de recalculer le même résultat plusieurs
                fois (mémoïsation).
            </li>
        </ul>
    </section>

    <section>
        <h3>Exercice</h3>
        <p>
            Parmi les fonctions suivantes, lesquelles sont pures ?
        </p>
        <ol>
            <li>
                <pre><code class="language-js">function add(x, y) { return x + y; }</code></pre>
            </li>
            <li>
                <pre><code class="language-js">function random() { return Math.random(); }</code></pre>
            </li>
            <li>
                <pre><code class="language-js">function greet(name) { return 'Hello, ' + name; }</code></pre>
            </li>
            <li>
                <pre><code class="language-js">function square(x) { return x * x; }</code></pre>
            </li>
            <li>
                <pre><code class="language-js">function now() { return new Date(); }</code></pre>
            </li>
            <li>
                <pre><code class="language-js">function display(message) { console.log(message); }</code></pre>
            </li>
            <li>
                <pre><code class="language-js">function sum(arr) { return arr.reduce((acc, x) => acc + x, 0); }</code></pre>
            </li>
            <li>
                <pre><code class="language-js">function uppercase(user) { user.lastname = user.lastname.toUpperCase(); }</code></pre>
            </li>
        </ol>
    </section>

    <section>
        <h3>React</h3>
        <p>
            React est une bibliothèque JavaScript open-source pour la <strong>création d'interfaces utilisateur</strong>
            qui utilise le paradigme de <strong>programmation fonctionnelle</strong> (bien qu'il était possible dans
            les premières versions de React de créer des composants en utilisant le paradigme de la programmation
            orientée objet).
        </p>
        <p>
            React utilise des composants pour structurer l'interface utilisateur et
            <a href="https://react.dev/reference/rules/components-and-hooks-must-be-pure" target="_blank">encourage</a>
            la création de composants <strong>purs</strong> qui ne dépendent que de leurs propriétés (props) pour
            afficher leur état.
        </p>
        <p>
            React utilise aussi le concept de
            <a href="https://react.dev/learn/react-compiler#what-does-the-compiler-do" target="_blank">mémoïsation</a>
            pour éviter de recalculer le rendu d'un composant si ses propriétés n'ont pas changé.
        </p>
    </section>

    <section>
        <h3>Expressions lambda</h3>
        <p>
            Les expressions lambda (également appelées fonctions anonymes) sont des fonctions sans nom qui sont souvent
            utilisées pour passer des fonctions en tant qu'arguments à d'autres fonctions.
        </p>
        <p>
            Nous avons vu un exemple d'expression lambda dans la section précédente avec la fonction
            <code class="language-js">filter()</code> :
        </p>
        <pre><code class="language-js">const arr = [1, 2, 3];
const filtered = arr.filter(function (x) { return x > 1; });</code></pre>
    </section>

    <section>
        <h3>Expressions lambda</h3>
        <p>
            En JavaScript, les expressions lambda peuvent être écrites de manière plus concise à l'aide de la syntaxe
            des <strong>fonctions fléchées</strong> :
        </p>
        <pre><code class="language-js">const arr = [1, 2, 3];
const filtered = arr.filter(x => x > 1);</code></pre>
        <p>
            Les fonctions fléchées sont plus courtes et plus lisibles que les fonctions anonymes traditionnelles.
        </p>
    </section>

    <section>
        <h3>Expressions lambda</h3>
        <p>
            Hormis une différence de syntaxe, les
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank">fonctions fléchées</a>
            ont un comportement légèrement différent en ce qui concerne le mot-clé <code class="language-js">this</code>.
        </p>
        <pre><code class="language-js">const person = {
    firstName: 'John',
    lastName: 'Doe',
    fullName: function() {
        let fn = function() {
            console.log(this); // this is the global object
            console.log(this.firstName + ' ' + this.lastName); // undefined undefined
        }
        fn();
        let lambda = () => {
            console.log(this); // this is the person object
            console.log(this.firstName + ' ' + this.lastName); // John Doe
        };
        lambda();
    }
}

person.fullName();</code></pre>
    </section>

    <section>
        <h3>Expressions lambda</h3>
        <p>
            On retrouve les expressions lambda dans de nombreux langages de programmation :
        </p>
        <ul>
            <li>
                En Python :<br>
                <code class="language-python">square = lambda x: x * x</code>.
            </li>
            <li>
                En C# :<br>
                <code class="language-csharp">Func&lt;int, int&gt; square = x => x * x;</code>.
            </li>
            <li>
                En Java :<br>
                <code class="language-java">Function&lt;Integer, Integer&gt; square = x -> x * x;</code>.
            </li>
        </ul>
    </section>

    <section>
        <h3>Expressions lambda - Exercice</h3>
        <div class="instructions">
            <ol>
                <li>
                    Créez une fonction lambda qui filtre les nombres pairs d'un tableau.
                </li>
                <li>
                    Créez une fonction lambda qui affiche un décompte de 3 à 0 en utilisant la fonction
                    <code class="language-js">setInterval()</code>.
                </li>
                <li>
                    Créez une fonction lambda qui calcule la somme des éléments d'un tableau en utilisant la méthode
                    <code class="language-js">reduce()</code>.
                </li>
                <li>
                    Créez une fonction lambda pour demander à l'utilisateur de saisir son prénom en utilisant le
                    module <code class="language-js">readline</code> de Node.js.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Récursivité</h3>
        <p>
            La récursivité est une technique de programmation dans laquelle une fonction s'appelle elle-même pour résoudre un problème plus petit.
        </p>
        <blockquote>
            <p>
                "To understand recursion, you must first understand recursion."
            </p>
            <cite>Anonymous</cite>
        </blockquote>
    </section>

    <section>
        <h3>Récursivité VS Itération</h3>
        <p>
            La récursivité est couramment utilisée en programmation fonctionnelle pour remplacer les boucles.
            Cependant, la récursivité ne permet pas d'améliorer les performances, car chaque appel de fonction crée une nouvelle pile d'exécution.
        </p>
        <div class="container">
            <div class="col">
                <h4>Récursivité</h4>
                <pre><code class="language-javascript">function factorial(n) {
    if (n === 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}</code></pre>
            </div>
            <div class="col">
                <h4>Itération</h4>
                <pre><code class="language-javascript">function factorial(n) {
    let result = 1;
    for (let i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}</code></pre>
            </div>
        </div>
        <footer>
            <a href="https://stackoverflow.com/questions/9386375/efficiency-recursion-vs-loop" target="_blank">Stack Overflow - Efficiency: recursion vs. loop</a>
        </footer>
    </section>

    <section>
        <h3>Récursivité en Haskell</h3>
        <p>
            Le langage Haskell est un langage de programmation fonctionnel pur qui repose sur la récursivité pour l'itération.
            Il ne supporte pas les boucles comme <code>for</code> ou <code>while</code> que l'on retrouve dans les langages impératifs.
        </p>
        <pre><code class="language-haskell">factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)

main :: IO ()
main = do
    print (factorial 5) -- 120</code></pre>
    </section>

    <section>
        <h3>Récursivité sur tableau</h3>
        <p>
            La récursivité peut être utilisée pour parcourir un tableau en appelant une fonction récursive sur chaque élément.
        </p>
        <pre><code class="language-js">function sum(arr) {
    if (arr.length === 0) {
        return 0;
    } else {
        return arr[0] + sum(arr.slice(1)); // Head + Tail
    }
}</code></pre>
        <p>
            En Haskell, cette fonction s'écrit de la manière suivante :
        </p>
        <pre><code class="language-haskell">sum :: [Integer] -> Integer
sum [] = 0
sum (head:tail) = head + sum tail</code></pre>
    </section>

    <section>
        <h3>Récursivité - Exercice</h3>
        <div class="instructions">
            <ol>
                <li>
                    Créez une fonction récursive <code class="language-js">flatten(arr)</code> qui retourne un tableau
                    à une dimension à partir d'un tableau multidimensionnel.
                    <pre><code class="language-js">console.log(flatten([1, [2, [3, [4]], 5]])); // [1, 2, 3, 4, 5]</code></pre>
                </li>
                <li>
                    Créez une fonction récursive <code class="language-js">binaryTreeSum(tree)</code> qui retourne la
                    somme des valeurs d'un arbre binaire.
                    <pre style="max-width: 100%; overflow-x: auto;"><code class="language-js">const tree = {
    value: 1,
    left: {
        value: 2,
        left: { value: 3, left: null, right: null },
        right: { value: 4, left: null, right: null }
    },
    right: { value: 5, left: null, right: null }
};
console.log(binaryTreeSum(tree)); // 15</code></pre>
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Promises</h3>
        <p>
            Une promesse (promise) est un objet qui représente la réussite ou l'échec d'une opération asynchrone.
        </p>
        <p>
            Les promesses sont couramment utilisées en JavaScript pour gérer les <strong>opérations asynchrones</strong>
            comme les appels réseau, les accès à la base de données ou les interactions avec l'utilisateur.
        </p>
        <pre><code class="language-js">const promise = new Promise((resolve, reject) => { // resolve et reject sont des fonctions de rappel
    setTimeout(() => {
        const success = Math.random() > 0.5;
        if (success) {
            resolve('Success!'); // La promesse est résolue
        } else {
            reject('Failure!'); // La promesse est rejetée
        }
    }, 1000);
});

promise.then(result => console.log(result)) // Success!
       .catch(error => console.error(error)); // Failure!</code></pre>
    </section>

    <section>
        <h3>Promises</h3>
        <p>
            Les promesses permettent de simplifier la gestion des opérations asynchrones en évitant le syndrome de
            <strong>l'entrelacement</strong> (<a href="http://callbackhell.com/" target="_blank">callback hell</a>).
        </p>
        <p>
            Elles sont très souvent utilisées en JavaScript avec les mots-clés <code>async</code> et <code>await</code>
            pour rendre le code plus lisible et plus facile à comprendre :
        </p>
        <pre><code class="language-js">function fetchData(url, callback, err) {
    fetch(url)
        .then(response => response.json())
        .then(json => callback(json));
        .catch(error => err(error));
}</code></pre>
        <pre><code class="language-js">async function fetchData(url) {
    const response = await fetch(url);
    const json = await response.json();
    return json;
}</code></pre>
    </section>

    <section>
        <h3>Promises - NodeJS</h3>
        <p>
            NodeJS propose dans sa bibliothèque standard des fonctions qui retournent des promesses, comme par exemple
            <code class="language-js">fs.promises.readFile()</code> pour lire un fichier.
        </p>
        <a href="https://nodejs.org/en/learn/manipulating-files/reading-files-with-nodejs" target="_blank">
            Node.js - Reading files with Node.js
        </a>
    </section>

    <section>
        <h3>Exercice - Promises</h3>
        <div class="instructions">
            <ol>
                <li>
                    Utilisez les fonctions <code class="language-js">fs.readdir()</code> et <code class="language-js">fs.stat()</code>
                    pour lister les fichiers d'un répertoire et afficher leur taille.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Closures</h3>
        <p>
            Une fermeture (closure) est une fonction qui capture les variables de son environnement lexical.
        </p>
        <p>
            Les fermetures sont couramment utilisées en JavaScript pour créer des fonctions qui conservent l'état de
            leur environnement d'exécution.
        </p>
        <pre><code class="language-js">function makeCounter() {
    let count = 0;
    return () => count++; // ⚠️ Cette fonction retourne la valeur actuelle de count
}

const counter = makeCounter();
console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2</code></pre>
    </section>

    <section>
        <h3>Closures</h3>
        <p>
            Les fermetures permettent de retrouver des concepts de la programmation orientée objet comme l'encapsulation
            et l'abstraction :
        </p>
        <pre><code class="language-js">function createPerson(name) {
    return {
        getName: () => name,
        setName: (newName) => name = newName
    };
}

const person = createPerson('Alice');
console.log(person.getName()); // Alice
person.setName('Bob');
console.log(person.getName()); // Bob</code></pre>
    </section>

    <section>
        <h3>Closure - Exercice</h3>
        <div class="instructions">
            <ol>
                <li>
                    Créez une fonction <code class="language-js">createCharacter(name, health)</code> qui retourne un
                    personnage avec un nom et une santé.
                </li>
                <li>
                    Créez une fonction <code class="language-js">getName()</code> qui retourne le nom du personnage.
                </li>
                <li>
                    Créez une fonction <code class="language-js">attack(character, damage)</code> qui réduit la santé
                    du personnage de la valeur du dommage.
                </li>
                <li>
                    Créez une fonction <code class="language-js">heal(health)</code> qui augmente la santé
                    du personnage de la valeur de la guérison.
                </li>
                <li>
                    Créez une fonction <code class="language-js">isAlive()</code> qui retourne <code>true</code>
                    si la santé du personnage est supérieure à zéro.
                </li>
                <li>
                    Créer une fonction <code class="language-js">doSomething()</code> qui effectue une action aléatoire
                    (attaque ou guérison) pendant un combat.
                </li>
                <li>
                    Créez une fonction <code class="language-js">fight()</code> qui simule un combat entre deux personnages.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Currying</h3>
        <p>
            La currification (currying) est une technique de <strong>transformation</strong> d'une fonction qui prend
            <strong>plusieurs arguments</strong> en une séquence de <strong>fonctions qui prennent un seul argument</strong>.
        </p>
        <p>
            La currification est basée sur le principe de fermeture (closure) et est couramment utilisée en programmation
            fonctionnelle pour créer des fonctions partielles.
        </p>
        <p>
            On peut représenter la currification d'une fonction <code class="language-js">add(x, y)</code> comme une
            suite de fonctions <code class="language-js">add(x)(y)</code> :
        </p>
        <pre><code class="language-js">function add(x) {
    return y => x + y;
}

const add2 = add(2);
console.log(add2(3)); // 5</code></pre>
    </section>

    <section>
        <h3>Currying - Exemple</h3>
        <p>
            La currification est utile pour créer des fonctions partielles qui peuvent être réutilisées avec des arguments
            différents.
        </p>
        <p>
            Dans cet exemple, nous avons une fonction <code class="language-js">log(date, level, message)</code>
            qui affiche un message de journalisation avec une date, un niveau de log et un message :
        </p>
        <pre><code class="language-js">function log(date, level, message) {
    console.log(`[${date}] [${level}] ${message}`);
}</code></pre>
        <p>
            L'utilisation de cette fonction est <strong>fastidieuse</strong>, car il faut spécifier la date et le
            niveau de log à chaque appel :
        </p>
        <pre><code class="language-js">log(new Date(), 'INFO', 'First log');
log(new Date(), 'INFO', 'Second log');</code></pre>
    </section>

    <section>
        <h3>Currying - Exemple</h3>
        <p>
            En utilisant la currification, nous pouvons créer une fonction <code class="language-js">info(message)</code>
            qui affiche un message de journalisation avec un niveau de log <code class="language-js">INFO</code> :
        </p>
        <pre><code class="language-js">const logToday = log(new Date());
const info = logToday('INFO');
info('First log');
info('Second log');</code></pre>
        <p>
            La fonction <code class="language-js">info()</code> est une fonction partielle qui conserve la date et le
            niveau de log pour chaque appel.
        </p>
        <p>
            Voici comment nous pouvons implémenter la currification de la fonction <code class="language-js">log()</code> :
        </p>
        <pre><code class="language-js">function log(date) {
    return level => message => console.log(`[${date}] [${level}] ${message}`);
}</code></pre>
    </section>

    <section>
        <h3>Currying - Exercice</h3>
        <div class="instructions">
            <ol>
                <li>
                    En utilisant la fonction précédente, comment créer et utiliser une fonction
                    <code class="language-js">errorToday(message)</code> qui affiche un message de journalisation avec un
                    niveau de log <code class="language-js">ERROR</code> ?
                </li>
                <li>
                    Créez une fonction <code class="language-js">add(x, y, z)</code> qui retourne la somme des trois
                    arguments.
                </li>
                <li>
                    En utilisant la fonction <code class="language-js">add()</code>, utilisez la currification pour créer une fonction <code class="language-js">add5(x)</code> qui
                    ajoute 5 à un nombre.
                </li>
                <li>
                    En utilisant la fonction <code class="language-js">add()</code>, utilisez la currification pour créer une fonction <code class="language-js">add10(x)</code> qui
                    ajoute 10 à un nombre.
                </li>
                <li>
                    En utilisant la fonction <code class="language-js">add()</code>, utilisez la currification pour créer une fonction <code class="language-js">add5and10(x)</code> qui
                    ajoute 5 et 10 à un nombre.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Higher-Order Functions</h3>
        <p>
            Les fonctions d'ordre supérieur (higher-order functions) sont des fonctions qui prennent d'autres fonctions
            en tant qu'arguments ou qui retournent des fonctions (ou les deux en même temps).
        </p>
        <p>
            Par exemple, nous avons vu la fonction <code class="language-js">filter()</code> qui prend une fonction
            de test en argument et retourne un nouveau tableau contenant les éléments qui passent le test.
        </p>
    </section>

    <section>
        <h3>React</h3>
        <p>
            React utilise le concept de fonctions d'ordre supérieur pour créer des <strong>composants réutilisables</strong>.
        </p>
        <p>
            Ces composants sont appelés <strong>High-order components (HOC)</strong>. Ils prennent un composant en
            argument et retournent un nouveau composant avec des fonctionnalités supplémentaires.
        </p>
    </section>

    <section>
        <h3>Exercice - mapToList</h3>
        <div class="instructions">
            <ul>
                <li>
                    Créer une fonction <code class="language-js">mapToList()</code> prenant en paramètre une fonction
                    de transformation et un tableau, et retournant un nouveau tableau avec les éléments transformés.
                </li>
                <li>
                    Cette fonction devra reproduire le comportement de la méthode <code class="language-js">map()</code>
                    de JavaScript, mais en ajoutant une puce devant chaque élément.
                </li>
                <li>
                    Exemple :
                    <pre><code class="language-js">const arr = [1, 2, 3];
const result = mapToList(x => x * x, arr);
console.log(result); // ['• 1', '• 4', '• 9']</code></pre>
                </li>
            </ul>
        </div>
    </section>

    <section>
        <h3>Exercice - Mémoization</h3>
        <p>
            La mémoïsation (memoization) est une technique de programmation qui consiste à stocker le résultat d'une
            fonction pour éviter de le recalculer si les mêmes arguments sont passés à nouveau.
        </p>
        <div class="instructions">
            <ol>
                <li>
                    Appelez la fonction <code class="language-js">fibonacci(n)</code> avec le nombre 40 et mesurez
                    le temps d'exécution en utilisant les méthodes <code class="language-js">console.time()</code>
                    et <code class="language-js">console.timeEnd()</code>.
                </li>
                <li>
                    Créez une fonction <code class="language-js">memoize(fn)</code> qui sera une fonction d'ordre supérieur
                    et qui prendra en paramètre une fonction et retournera une nouvelle fonction qui mémorisera les résultats.
                </li>
            </ol>
        </div>
        <p>
            Vous aurez besoin de récupérer l'ensemble des arguments passés à une fonction. Pour cela, vous pouvez utiliser
            le spread operator <code class="language-js">...</code> :
        </p>
        <pre><code class="language-js">(...args) => { /* ... */ }</code></pre>
        <footer>
            <a href="#" class="info">La mémoïsation utilise le concept de fermeture (closure)</a>
        </footer>
    </section>

    <section>
        <h3>Exercice - TicTacToe</h3>
        <p>
            Reproduire le jeu du Morpion (Tic-Tac-Toe) que vous avez réalisé en programmation orientée objet pour le
            reproduire en utilisant la programmation fonctionnelle.
        </p>
        <div class="instructions">
            <ol>
                <li>
                    Utilisez des fonctions pures pour gérer l'état du jeu.
                </li>
                <li>
                    Utilisez des expressions lambda pour effectuer des traitements sur les tableaux.
                </li>
                <li>
                    Utilisez des fermetures (closures) pour encapsuler les variables de l'environnement.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Exercice - TicTacToe (Bonus)</h3>
        <p>
            Proposez une version améliorée du jeu du Morpion (Tic-Tac-Toe) en ajoutant la possibilité de jouer
            <strong>contre l'ordinateur</strong>.
        </p>
        <p>
            Pour cela, vous pouvez utiliser l'algorithme <strong>Minimax</strong> et la récursivité pour que
            l'ordinateur choisisse le meilleur coup à jouer.
        </p>
        <footer>
            <a href="https://fr.wikipedia.org/wiki/Algorithme_minimax" class="info" target="_blank">Wikipédia - Algorithme minimax</a>
        </footer>
    </section>

</section>
<section id="logic">

    <section>
        <h2>Paradigmes Logique</h2>
    </section>

    <section>
        <h3>Programmation logique</h3>
        <p>
            La programmation logique est un sous domaine de la <strong>programmation déclarative</strong>. Elle est
            basée sur la logique mathématique et repose sur le concept de <strong>prédicats</strong> et de
            <strong>règles logiques</strong>.
        </p>
        <p>
            Le langage de programmation le plus connu pour la programmation logique est <strong>Prolog</strong>.
        </p>
        <p>
            Le langage Prolog peut être <strong>comparé au langage SQL</strong> pour les bases de données.
            Cependant, on ne va pas créer des données avec Prolog, mais plutôt des règles logiques et des relations.
        </p>
    </section>

    <section>
        <h3>Prolog</h3>
        <p>
            Prolog est un langage de programmation logique inventé en 1972 par Alain Colmerauer et Philippe Roussel.
            Il est basé sur la logique du premier ordre et repose sur le concept de <strong>prédicats</strong> (facts)
            et de <strong>règles logiques</strong> (rules).
        </p>
        <p>
            Prolog est un langage de programmation déclaratif, ce qui signifie que l'on décrit ce que l'on veut obtenir
            plutôt que comment l'obtenir.
        </p>
    </section>

    <section>
        <h3>Installation</h3>
        <p>
            Pour installer Prolog sur votre machine, vous pouvez utiliser le gestionnaire de paquets de votre système
            d'exploitation.
        </p>
        <div class="container">
            <div class="col">
                <h4>macOS</h4>
                <pre class="language-bash"><code>brew install gnu-prolog</code></pre>
            </div>
            <div class="col">
                <h4>Windows</h4>
                <pre class="language-bash"><code>scoop bucket add extras
scoop install swipl</code></pre>
            </div>
        </div>
        <p>
            Vous pouvez ensuite exécuter Prolog en tapant la commande <code>prolog</code> dans un terminal ou bien
            en créant un fichier avec l'extension <code>.pl</code> et en l'exécutant avec la commande suivante :
        </p>
        <pre><code class="language-shell">gprolog
| ?- [hello].</code></pre>
        <pre><code class="language-shell">swipl -s hello.pl</code></pre>
        <p>
            Vous pouvez également utiliser un <a href="https://swish.swi-prolog.org/" target="_blank">interpréteur en ligne</a>
            pour tester Prolog sans l'installer sur votre machine.
        </p>
    </section>

    <section>
        <h3>Exemple</h3>
        <p>
            Voici un exemple de programme Prolog qui définit des faits et des règles pour déterminer si un animal est
            un mammifère ou un oiseau :
        </p>
        <pre><code class="language-prolog">% Facts
mammal(dog).
mammal(cat).
bird(sparrow).
bird(eagle).

% Rules
animal(X) :- mammal(X).
animal(X) :- bird(X).</code></pre>
        <p>
            On peut ensuite poser des questions à Prolog pour déterminer si un animal est un mammifère ou un oiseau :
        </p>
        <pre><code class="language-prolog">?- animal(dog).
true.

?- bird(sparrow).
true.

?- animal(fish).
false.</code></pre>
    </section>

    <section>
        <h3>Termes</h3>
        <p>
            En Prolog, les données sont représentées par des <strong>termes</strong>. Un terme peut être un <strong>atome</strong>,
            un <strong>nombre</strong>, une <strong>variable</strong> ou une <strong>structure</strong>.
        </p>
        <ul>
            <li>
                Un <strong>atome</strong> est un symbole qui représente une constante.
                Par exemple : <code>dog</code>, <code>cat</code>, <code>sparrow</code>, <code>eagle</code>.
                Il doit commencer par une lettre minuscule ou être entouré de guillemets simples.
            </li>
            <li>
                Un <strong>nombre</strong> est un entier ou un nombre à virgule flottante.
                Par exemple : <code>42</code>, <code>3.14</code>.
            </li>
            <li>
                Une <strong>variable</strong> est un symbole qui commence par une majuscule ou un underscore.
                Par exemple : <code>X</code>, <code>Y</code>, <code>_Z</code>.
            </li>
            <li>
                Une <strong>structure</strong> est un terme composé d'un <strong>foncteur</strong> et d'un nombre
                d'arguments.
                Par exemple : <code>animal(dog)</code>, <code>point(3, 4)</code>.
            </li>
        </ul>
        <p>
            Il est également possible de manipuler des listes en Prolog (par exemple : <code>[1, 2, 3]</code>) ou
            encore des chaînes de caractères (par exemple : <code>"hello, world!"</code>).
        </p>
    </section>

    <section>
        <h3>Aucun typage</h3>
        <p>
            Contrairement à d'autres langages de programmation, Prolog n'a pas de typage explicite pour les variables.
            Cela signifie que les variables peuvent contenir n'importe quel type de données sans avoir besoin de les
            déclarer.
        </p>
        <p>
            Par exemple, la variable <code>X</code> peut contenir un atome, un nombre, une liste ou une structure.
        </p>
        <p>
            Cela permet à Prolog d'être plus flexible et de manipuler des données de manière plus générique.
        </p>
    </section>

    <section>
        <h3>Faits (facts)</h3>
        <p>
            Les <strong>faits</strong> sont des déclarations qui sont vraies dans un monde donné. Ils sont utilisés
            pour décrire des connaissances sur le monde.
        </p>
        <p>
            En Prolog, les faits sont définis en utilisant des prédicats avec des arguments. Par exemple, le fait
            <code>mammal(dog)</code> signifie que le chien est un mammifère.
        </p>
        <p>
            Voici d'autres exemples de faits en Prolog :
        </p>
        <pre><code class="language-prolog">color(red). % red is a color
mother(marge, bart). % marge is the mother of bart
love(romeo, juliet). % romeo loves juliet</code></pre>
        <p>
            Le caractère <code class="language-prolog">.</code> est utilisé pour terminer un fait ou une règle en Prolog.
        </p>
    </section>

    <section>
        <h3>Règles (rules)</h3>
        <p>
            Les <strong>règles</strong> sont des déclarations qui définissent des relations entre les faits. Elles sont
            utilisées pour déduire de nouvelles informations à partir des faits existants.
        </p>
        <p>
            En Prolog, les règles sont définies en utilisant des prédicats avec des variables. Par exemple, la règle
            <code>animal(X) :- mammal(X)</code> signifie que si X est un mammifère, alors X est un animal.
        </p>
        <p>
            Voici d'autres exemples de règles en Prolog :
        </p>
        <pre><code class="language-prolog">parent(X, Y) :- mother(X, Y). % X is the parent of Y if X is the mother of Y
grandparent(X, Z) :- parent(X, Y), parent(Y, Z). % X is the grandparent of Z if X is the parent of Y and Y is the parent of Z</code></pre>
        <p>
            Dans l'exemple ci-dessus, le symbole <code class="language-prolog">:-</code> est utilisé pour définir une
            règle en Prolog tandis que la virgule <code class="language-prolog">,</code> est utilisée pour effectuer
            une conjonction (AND). Le point-virgule <code class="language-prolog">;</code> est utilisé pour effectuer
            une disjonction (OR).
        </p>
    </section>

    <section>
        <h3>Exercice - Étudiants / Enseignants</h3>
        <p>
            Utilisez Prolog pour résoudre le problème suivant :
        </p>
        <div class="instructions">
            <ol>
                <li>
                    Écrire en Prolog les faits suivants :
                    <ul>
                        <li>John étudie la programmation.</li>
                        <li>Tom étudie les mathématiques.</li>
                        <li>Alice enseigne les mathématiques.</li>
                        <li>Mary enseigne la programmation.</li>
                    </ul>
                </li>
                <li>
                    Écrire en Prolog les règles suivantes :
                    <ul>
                        <li>Un étudiant est une personne qui étudie une matière.</li>
                        <li>Un enseignant est une personne qui enseigne une matière.</li>
                        <li>Un étudiant à un enseignant s'il étudie une matière enseignée par cet enseignant.</li>
                    </ul>
                </li>
                <li>
                    Poser les questions suivantes à Prolog :
                    <ul>
                        <li>Est-ce que John est un étudiant ?</li>
                        <li>Est-ce que Mary est une étudiante ?</li>
                        <li>Est-ce que Mary enseigne à John ?</li>
                    </ul>
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Règles (rules) - Opérateurs</h3>
        <p>
            En Prolog, il existe plusieurs opérateurs logiques qui peuvent être utilisés pour définir des règles.
        </p>
        <ul>
            <li>
                L'opérateur <code class="language-prolog">,</code> est utilisé pour effectuer une conjonction (AND).
                <pre><code class="language-prolog">grandparent(X, Z) :- parent(X, Y), parent(Y, Z).</code></pre>
            </li>
            <li>
                L'opérateur <code>;</code> est utilisé pour effectuer une disjonction (OR).
                <pre><code class="language-prolog">parent(X, Y) :- mother(X, Y); father(X, Y).</code></pre>
            </li>
            <li>
                L'opérateur <code>\+</code> est utilisé pour effectuer une négation (NOT).
                <pre><code class="language-prolog">not_parent(X, Y) :- \+ parent(X, Y).</code></pre>
            </li>
            <li>
                L'opérateur <code>==</code> est utilisé pour effectuer une égalité stricte (STRICT EQUAL).
                <pre><code class="language-prolog">same(X, Y) :- X == Y.</code></pre>
            </li>
            <li>
                L'opérateur <code>\=</code> est utilisé pour effectuer une différence (NOT EQUAL).
                <pre><code class="language-prolog">different(X, Y) :- X \= Y.</code></pre>
            </li>
        </ul>
    </section>

    <section>
        <h3>Exercice - Étudiants / Enseignants</h3>
        <div class="instructions">
            <ol>
                <li>
                    Ajouter une règle pour déterminer si une personne est spécialisée dans les mathématiques c'est-à-dire
                    si elle enseigne uniquement les mathématiques.
                </li>
                <li>
                    Ajouter une règle pour déterminer si une personne est spécialisée dans une seule matière quelqu'elle
                    soit.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Unification</h3>
        <p>
            L'<strong>unification</strong> est un concept fondamental en Prolog. C'est un mécanisme qui permet de
            comparer deux termes et de les rendre égaux en instanciant les variables.
        </p>
        <p>
            Par exemple, si on a les termes <code>animal(X)</code> et <code>animal(dog)</code>, on peut les unifier
            en instanciant la variable <code>X</code> avec <code>dog</code>.
        </p>
        <p>
            L'unification est utilisée pour résoudre les requêtes en Prolog en trouvant les valeurs des variables
            qui rendent les prédicats vrais.
        </p>
        <p>
            Voici un exemple d'unification en Prolog :
        </p>
        <pre><code class="language-prolog">?- animal(X) = animal(dog).
X = dog</code></pre>
        <footer>
            <a href="#" class="warning" style="font-size: 0.7em">
                L'unification est totalement différente de l'affectation en programmation impérative.
            </a>
        </footer>
    </section>

    <section>
        <h3>Unification - Exemples</h3>
        <p>
            Voici quelques exemples d'unification en Prolog :
        </p>
        <pre><code class="language-prolog">?- 1 = 1. % yes
?- 1 + 1 = 2. % no (ici, Prolog ne fait pas d'évaluation arithmétique et compare en réalité '+'(1, 1) avec 2)
?- X = 42 + 3. % X = 42+3</code></pre>
        <p>
            En utilisant l'unification et les variables avec des règles, on peut déduire de nouvelles informations à
            partir des faits :
        </p>
        <pre><code class="language-prolog">?- parent(X, bart). % X = marge</code></pre>
        <p>
            L'instruction précédente permet de déduire que Marge est la mère de Bart, mais il serait possible de
            déduire également que Homer est le père de Bart en ajoutant un fait
            <code class="language-prolog">father(homer, bart)</code> et en appuyant sur
            <code class="language-prolog">;</code> pour demander à Prolog de <strong>chercher une autre solution</strong>.
            Cette fonctionnalité est appelée <strong>backtracking</strong>.
        </p>
    </section>

    <section>
        <h3>Unification - Exercice</h3>
        <p>
            À partir des exercices précédents, essayez de poser des questions à Prolog pour déduire de nouvelles
            informations en utilisant l'unification.
        </p>
        <div class="instructions">
            <ol>
                <li>
                    Déduire qui enseigne la programmation.
                </li>
                <li>
                    Déduire qui étudie les mathématiques.
                </li>
                <li>
                    Déduire quels sont les enseignants de John.
                </li>
                <li>
                    Déduire quels sont les étudiants d'Alice.
                </li>
            </ol>
        </div>
    </section>

    <section>
        <h3>Listes</h3>
        <p>
            Les <strong>listes</strong> sont un concept fondamental en Prolog. Elles sont utilisées pour représenter
            des ensembles d'éléments ordonnés.
        </p>
        <p>
            Une liste vide est représentée par le symbole <code>[]</code>. Une liste non vide est représentée par
            un <strong>terme composé</strong> avec un <strong>foncteur</strong> <code>.</code> et deux arguments :
            la <strong>tête</strong> de la liste et la <strong>queue</strong> de la liste.
        </p>
        <p>
            Par exemple, la liste <code>[1, 2, 3]</code> est représentée en Prolog par <code>[1, [2, [3, []]]]</code>.
        </p>
        <p>
            Il existe en Prolog des predicats prédéfinis pour manipuler les listes, comme <code>member</code>,
            <code>append</code>, <code>reverse</code>, etc.
        </p>
    </section>

    <section>
        <h3>Listes - Exemples</h3>
        <p>
            Voici quelques exemples de manipulation de listes en Prolog :
        </p>
        <pre><code class="language-prolog">?- member(2, [1, 2, 3]). % yes
?- append([1, 2], [3, 4], X). % X = [1, 2, 3, 4]
?- reverse([1, 2, 3], X). % X = [3, 2, 1]</code></pre>
        <p>
            L'opérateur <code>|</code> peut être utilisé pour décomposer une liste en tête et queue :
        </p>
        <pre><code class="language-prolog">?- [Head | Tail] = [1, 2, 3]. % Head = 1, Tail = [2, 3]</code></pre>
        <p>
            Cela permet de manipuler les éléments d'une liste de manière récursive en Prolog :
        </p>
        <pre><code class="language-prolog">sum([], 0). % sum of an empty list is 0
sum([Head | Tail], Total) :- sum(Tail, Sum), Total is Head + Sum.</code></pre>
        <p>
            Le mot clé <code class="language-prolog">is</code> est utilisé pour évaluer une expression arithmétique en
            Prolog (car le signe <code class="language-prolog">=</code> est déjà utilisé pour l'unification).
        </p>
    </section>

    <section>
        <h3>Debugger avec Trace</h3>
        <p>
            Prolog dispose d'un outil de <strong>debugging</strong> appelé <strong>trace</strong> qui permet de suivre
            l'exécution d'un programme pas à pas.
        </p>
        <p>
            Pour activer le mode trace, il suffit de taper la commande <code>trace.</code> dans l'interpréteur Prolog
            puis d'exécuter une requête. Prolog affichera alors chaque étape de l'exécution du programme.
            (<code>notrace.</code> permet de désactiver le mode trace).
        </p>
        <div class="container">
            <div class="col">
                <p>
                    Dans l'exemple ci-contre, <code class="language-prolog">_29</code>,
                    <code class="language-prolog">_98</code>... sont des variables anonymes qui sont utilisées pour
                    représenter des variables temporaires.
                </p>
                <p>
                    Les chiffres à gauche de chaque ligne représentent le numéro de la procédure et la profondeur de
                    l'appel récursif.
                </p>
            </div>
            <div class="col">
                <pre><code class="language-prolog">| ?- sum([1,2,3], X).
1    1  Call: sum([1,2,3],_29) ?
2    2  Call: sum([2,3],_98) ?
3    3  Call: sum([3],_122) ?
4    4  Call: sum([],_146) ?
4    4  Exit: sum([],0) ?
5    4  Call: _174 is 3+0 ?
5    4  Exit: 3 is 3+0 ?
3    3  Exit: sum([3],3) ?
6    3  Call: _203 is 2+3 ?
6    3  Exit: 5 is 2+3 ?
2    2  Exit: sum([2,3],5) ?
7    2  Call: _29 is 1+5 ?
7    2  Exit: 6 is 1+5 ?
1    1  Exit: sum([1,2,3],6) ?</code></pre>
            </div>
        </div>
    </section>

    <section>
        <h3>Listes - exercice</h3>
        <p>
            Utilisez Prolog pour résoudre le problème suivant :
        </p>
        <p>
            Une rue est composée de 3 maisons, chacune ayant une couleur différente (rouge, vert ou bleu) et habitée par une personne
            de nationalité différente (Espagnol, Italien, Français).
        </p>
        <ul>
            <li>L'Espagnol habite à droite de la maison rouge.</li>
            <li>L'Italien habite la seconde maison.</li>
            <li>Le Français habite dans la maison bleue.</li>
        </ul>
        <p>
            Qui habite dans la maison verte ?
            Qui habite dans la première maison ?
            ...
        </p>
    </section>

    <section>
        <h3>Exercice - Tic Tac Toe</h3>
        <p>
            Reproduire le jeu du Morpion (Tic-Tac-Toe) que vous avez réalisé en programmation orientée objet puis
            en programmation fonctionnelle en utilisant cette fois-ci la programmation logique avec Prolog.
        </p>
        <div class="instructions">
            <ol>
                <li>
                    Définir les faits et les règles pour représenter le jeu du Morpion.
                </li>
                <li>
                    Implémenter un prédicat permettant de vérifier si un joueur a gagné.
                </li>
            </ol>
        </div>
    </section>

</section>

    
</body>
</html>